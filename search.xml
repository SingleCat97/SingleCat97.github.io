<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title></title>
    <url>%2F2019%2F05%2F28%2Fjava%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%2F</url>
    <content type="text"><![CDATA[title: JAVA面向对象date: 2019-05-02 22:46:07tags: java面向对象 面向对象概述1Java语言是一种面向对象的程序设计语言，而面向对象思想是一种程序设计思想，我们在面向对象思想的指引下，使用Java语言去设计、开发计算机程序。 这里的对象泛指现实中一切事物，每种事物都具备自己的属性和行为。面向对象思想就是在计算机程序设计过程中，参照现实中事物，将事物的属性特征、行为特征抽象出来，描述成计算机事件的设计思想。 它区别于面向过程思想，强调的是通过调用对象的行为来实现功能，而不是自己一步一步的去操作实现。 举例1234567洗衣服:面向过程：把衣服脱下来 --&gt;找一个盆--&gt;放点洗衣粉--&gt;加点水--&gt;浸泡10分钟--&gt;揉一揉--&gt;清洗衣服--&gt;拧干--&gt;晾起来面向对象：把衣服脱下来 --&gt;打开全自动洗衣机--&gt;扔衣服--&gt;按钮--&gt;晾起来区别 :面向过程：强调步骤。面向对象：强调对象，这里的对象就是洗衣机。 特点1231、是一种更符合人们思考习惯的思想2、将复杂的事情简单化3、将人们从执行者变成了指挥者 本质1不断的寻找对象, 创建对象, 指挥对象做事情 特征1封装，继承，多态 基本定义类 对事物、逻辑、算法或概念的抽象。描述一类对象的行为和状态。 对象（实例） 对象是类的一个实例（对象不是找个女朋友），有状态和行为。 引用 java中，一切都“看作”对象，但操纵的标识符实际是指向一个对象的“引用”（reference）。” 构造方法 新建对象时，执行的一个特殊方法 在创建一个对象的时候，至少要调用一个构造方法 构造方法的名称必须与类同名，一个类可以有多个构造方法 this 引用当前对象 构造方法之间调用 方法重载overload 在子类中定义一个与父类中方法同名，同参数列表的方法 方法重写和重载的区别 重载规则：必须具有不同的参数列表； 可以有不同的返回类型；可以有不同的访问修饰 符；可以抛出不同的异常。 重写规则：参数列表必须完全与被重写的方法相同，否则不能称其为重写而是重载；返回 类型必须一直与被重写的方法相同，否则不能称其为重写而是重载；访问修饰符的限制一 定要大于等于被重写方法的访问修饰符；重写方法一定不能抛出新的检查异常或者比被重 写方法申明更加宽泛的检查型异常，譬如父类方法声明了一个检查异常 IOException，在 重写这个方法时就不能抛出 Exception，只能抛出 IOException 的子类异常，可以抛出 非检查异常。 重载与重写是 Java 多态性的不同表现。 重写是父类与子类之间多态性的表现，在运行时起作用（动态多态性，譬如实现动态绑定） 而重载是一个类中多态性的表现，在编译时起作用（静态多态性，譬如实现静态绑定）。 抽象类 作用 为子类提供通用代码 为子类提供通用方法的定义 注意点 抽象类不能创建对象 包含抽象方法的类，必须是抽象类 抽象类中，不一定有抽象方法 final 最终不可变的 修饰变量、方法、类 static（静态） 静态变量属于类，可以成为“类变量” 非静态成员属于实例 静态成员通常使用类名直接调用 被static修饰的成员将最优先加载到内存 接口 作用 结构设计工具，用来解耦合 极端的抽象类 用interface替代class 用implements替代extends 接口中只能定义 公共的常量 公共的抽象方法 公共的内部类、内部接口 内部类 定义 定义在类内部，方法内部或局部代码块中的类 非静态内部类 非静态内部类依赖于外部类对象存在 在非静态内部类中，不能定义静态成员 静态内部类 使用static修饰的成员内部类，称之为静态内部类 静态内部类只能访问外部类的静态成员 不能直接访问外部类的非静态成员 局部内部类 定义 声明在方法内部的类 局部类型，只能在局部使用 但它的实例，可以转为父类型传递出去 注意 不可以使用任何访问权限修饰符 不可以直接访问局部变量（方法的参数等效于局部变量） 如果一定需要访问，则需要使用final对局部变量进行修饰 成员内部类 在类（外部类）的内部，且与外部类的成员是“同一级别”的 匿名内部类 直接创建已知的类的子类的对象，则该对象的类型就是匿名内部类 java面对对象三大特性封装 概述 将属性隐藏起来，若需要访问某个属性，提供公共方法对其访问 封装的步骤 1. 使用 private 关键字来修饰成员变量。 2. 对需要访问的成员变量，提供对应的一对 getXxx 方法 、 setXxx 方法，用于对这 些属性的存取，在赋值方法中,加入对属性的存取控制语句 访问控制符 private 成员变量和方法只能在类内被访问,具有类可见性. default 成员变量和方法只能被同一个包里的类访问,具有包可见性 protected 可以被同一个包中的类访问,被同一个项目中不同包中的子类访问 public 可以被同一个项目中所有类访问,具有项目可见性,这是最大的访问权限 private的使用格式 private 数据类型 变量名 ； 1. 使用 private 修饰成员变量，代码如下： public class Student { private String name; private int age; } 2. 提供 getXxx 方法 / setXxx 方法，可以访问成员变量，代码如下： public class Student { private String name; private int age; public void setName(String n) { name = n; } public String getName() { return name; } public void setAge(int a) { age = a; } public int getAge() { return age; } } 3.this关键字优化 上述setXxx 方法中的形参名字并不符合见名知意的规定，如果修改与成员变量 名一致，由于形参变量名与成员变量名重名，导致成员变量名会被隐藏，方法中的变量 名，无法访问到成员变量，从而赋值失败。所以，我们需要使用this关键字，来解决 这个重名问题。 this的含义 this代表所在类的当前对象的引用（地址值），即对象自己的引用。 方法被哪个对象调用，方法中的this就代表那个对象。即谁在调用，this就代 表谁。 this使用格式 this.成员变量名； 使用 this 修饰方法中的变量，解决成员变量被隐藏的问题，代码如下 public class Student { private String name; private int age; public void setName(String name) { this.name = name; } public String getName() { return name; } public void setAge(int age) { this.age = age; } public int getAge() { return age; } } 4.构造方法优化 当一个对象被创建时候，构造方法用来初始化该对象，给对象的成员变量赋初始值。 构造方法的定义格式 修饰符 构造方法名(参数列表){ // 方法体 } 构造方法的写法上，方法名与它所在的类名相同。它没有返回值，所以不需要返回值 类型，甚至不需要void。使用构造方法后，代码如下： public class Student { private String name; private int age; // 无参数构造方法 public Student() {} // 有参数构造方法 public Student(String name,int age) { this.name = name; this.age = age; } } 注意事项 1. 如果你不提供构造方法，系统会给出无参数构造方法。 2. 如果你提供了构造方法，系统将不再提供无参数构造方法。 3. 构造方法是可以重载的，既可以定义参数，也可以不定义参数。 5.标准代码——JavaBean JavaBean 是 Java语言编写类的一种标准规范。符合 JavaBean 的类，要求类必须 是具体的和公共的，并且具有无参数的构造方法，提供用来操作成员变量的 set 和 get 方法。 student类 public class Student { //成员变量 private String name; private int age; //构造方法 public Student() {} public Student(String name,int age) { this.name = name; this.age = age; } //成员方法 publicvoid setName(String name) { this.name = name; } public String getName() { return name; } publicvoid setAge(int age) { this.age = age; } publicint getAge() { return age; } } 测试类 public class TestStudent { public static void main(String[] args) { //无参构造使用 Student s= new Student(); s.setName(&quot;柳岩&quot;); s.setAge(18); System.out.println(s.getName()+&quot;‐‐‐&quot;+s.getAge()); //带参构造使用 Student s2= new Student(&quot;千反田&quot;,18); System.out.println(s2.getName()+&quot;‐‐‐&quot;+s2.getAge()); } } 封装好处 隐藏类的实现细节 让使用者只能通过程序员规定的方法来访问数据 可以方便的加入存取控制语句,限制不合理操作 继承 概念 就是子类继承父类的属性和行为，使得子类对象具有与父类相同的属性、相同的行为。子 类可以直接访问父类中的非私有的属性和行为。继承通过extends关键字来实现,其中SubClass 为子类,SuperClass称为父类,基类,或超类 格式 class 父类 { ... } class 子类 extends 父类 { ... } 实例 /* * 定义员工类Employee，做为父类 */ class Employee { String name; // 定义name属性 // 定义员工的工作方法 public void work() { System.out.println(&quot;尽心尽力地工作&quot;); } } /* * 定义讲师类Teacher 继承 员工类Employee */ class Teacher extends Employee { // 定义一个打印name的方法 public void printName() { System.out.println(&quot;name=&quot; + name); } } /* * 定义测试类 */ public class ExtendDemo01 { public static void main(String[] args) { // 创建一个讲师类对象 Teacher t = new Teacher(); // 为该员工类的name属性进行赋值 t.name = &quot;小明&quot;; // 调用该员工的printName()方法 t.printName(); // name = 小明 // 调用Teacher类继承来的work()方法 t.work(); // 尽心尽力地工作 } } 作用 代码重用，代码复用 单继承 一个类，只能继承一个父类 一个类，可以有多个子类 不继承 构造方法不继承 没有访问权限的成员不继承 静态成员不继承 子父类中的成员关系 成员变量 1.在方法的局部变量中寻找，有则使用 2.在本类的成员变量中寻找，有则使用 3.在父类的成员变量中寻找，有则使用 4.都没有，报错 成员方法 1.在子类中寻找，有则使用 2.在父类中寻找，有则使用 3.没有，报错 构造方法 子类的初始化过程中，必须先执行父类的初始化动作。子类的构造方法中默认有一 个 super() ，表示调用父类的构造方法，父类成员变量初始化后，才可以给子类用。 当父类没有无参构造方法时，必须使用this或super调用其他的构造方法 this和super的区别 this : 代表本类对象的引用 super : 代表父类的存储空间 抽象类 概念 把一类事物的共性抽取出来的那个父类, 就定义成抽象类 特点 抽象类和抽象方法都要用abstract进行修饰 抽象类不能被实例化（不能创建对象） 抽象类中不一定有抽象方法，但是有抽象方法的类一定是抽象类 抽象类中数据的特点 成员变量：可以是常量，也可以是变量 成员方法：可以是抽象方法，也可以是非抽象方法 构造方法：有 格式 abstract class 类名字 { 抽象方法 普通方法 } 使用 继承抽象类的子类必须重写父类所有的抽象方法。否则，该子类也必须声明为抽象类。最 终，必须有子类实现该父类的抽象方法，否则，从最初的父类到最终的子类都不能创建对象，失 去意义。 抽象类中的问题 抽象类中是否有构造方法？能不能实例化？如果不能，为什么有构造方法 抽象类有构造方法 抽象类不能被实例化 抽象类中的构造方法供子类实例化调用 抽象关键字abstract不可以和那些关键字共存 private：被修饰的内容是子类继承不到的，所以不能重写，但是abstract修饰的方 法是要求被重写的 final：被final修饰的方法是不能被重写的 static：如果一个抽象方法通过static修饰，这个方法可以直接通过类名调用，但 是抽象方法没有方法体，这样的调用没有意义 抽象类中可不可以没有抽象方法？如果可以，这样的类有什么作用？ 抽象类可以没有抽象方法 抽象类中没有抽象方法的作用，只是为了不让别的类建立该抽象类对象 群主发红包 群主发普通红包。某群有多名成员，群主给成员发普通红包。普通红包的规则： 1. 群主的一笔金额，从群主余额中扣除，平均分成n等份，让成员领取。 2. 成员领取红包后，保存到成员余额中。 // 这是一个群主类 public class GroupMaster extends User{ // 根据父类生成的有参构造 public GroupMaster(String username, double leftMoney) { super(username, leftMoney); } /** * 此方法用来发红包 * * @param money 红包总金额 * @param count 红包总个数 * @return 一个大红包 */ public ArrayList&lt;Double&gt; sendRedBag(int money, int count) { // 判断自己的余额是否可以发这个红包 if (getLeftMoney() &lt; money) { // 如果钱不够 // 不发红包了 return null; } // 创建一个代表大红包的集合 ArrayList&lt;Double&gt; list = new ArrayList&lt;&gt;(); // 将元变成分, 减小误差 money = money * 100; // 获取每一个红包的金额 int perMoney = money / count; // 不能平均分配, 获取最后剩下的一点钱 int left = money % count; // 先不发最后一个 for (int i = 0; i &lt; count - 1; i++) { list.add(perMoney / 100.0); } // 只放最后一个小红包 list.add((perMoney + left) / 100.0); // 减少自己的余额 原有的余额, 减去红包的总金额 setLeftMoney(getLeftMoney() - money / 100); // 返回大红包 return list; } } public abstract class User { private String username; private double leftMoney; public User(String username, double money) { this.username = username; this.leftMoney = money; } public String getUsername() { return username; } public void setUsername(String username) { this.username = username; } public double getLeftMoney() { return leftMoney; } public void setLeftMoney(double leftMoney) { this.leftMoney = leftMoney; } } public class Member extends User { public Member(String username, double money) { super(username, money); } public void openRedBag(ArrayList&lt;Double&gt; list) { // 判断是否有红包 if (list == null) { System.out.println(&quot;对不起, 没红包!~&quot;); // 结束方法 return; } // 抢红包 // 获取集合中的值 -&gt; 值是通过索引获取 -&gt; 随机获取索引 // 创建随机数对象 Random r = new Random(); // 这个随机数的范围, 和集合的索引范围 int randomIndex = r.nextInt(list.size()); // 获取红包金额 double getMoney = list.get(randomIndex); // 红包抢一个, 没一个, 将小红包从大红包中删除 list.remove(randomIndex); // 简单修改自己的金额 setLeftMoney(getMoney); System.out.println(getUsername() + &quot;抢了&quot; + getMoney +&quot;元&quot;); } } public class Demo { public static void main(String[] args) { GroupMaster gm = new GroupMaster(&quot;杨xx&quot;, 100); Member m1 = new Member(&quot;方xx&quot;, 0); Member m2 = new Member(&quot;张x&quot;, 0); Member m3 = new Member(&quot;李x&quot;, 0); ArrayList&lt;Double&gt; list = gm.sendRedBag(200, 3); m1.openRedBag(list); m2.openRedBag(list); m3.openRedBag(list); } } 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859接口 概念 当一个类中的方法都是抽象的时候，java提供了另一种表示方式，叫接口 用interface关键字表示，类和接口关系用implements表示 格式 public interface 接口名称 &#123; // 抽象方法 // 默认方法 // 静态方法 // 私有方法 &#125; 抽象方法: 让子类重写 默认方法: 如果每一个子类需要具备相同的功能, 就可以再接口中定义具备这种功能的默认 方法 静态方法: 只能使用接口名. 去调用 私有方法: 只能在本类中使用, 私有的普通方法是为默认方法服务, 私有静态方法, 为普 通静态方法服务 成员特点 成员变量：是常量，默认修饰public static final 成员方法：都是抽象的，默认修饰public abstract 关系 类和类的关系 都是抽象的，默认修饰public abstract 类和接口的关系 实现关系，类可以多实现接口，使用关键字implement 类在继承一个类的同时，可以实现多个接口 接口和接口的关系 是继承关系，接口可以多继承 特点 是对外暴露的规则 是功能的扩展 接口的出现降低耦合性 接口可以多实现，如usb接口，榨汁机 和抽象类的区别 A 抽象类只能被单继承 接口可以多实现，接口的出现避免了多继承的局限性 B 抽象类中的数据特点 成员变量：可以是常量，也可以是变量 成员方法：可以是抽象方法，也可以是非抽象方法 构造方法：有 接口中的数据特点 成员变量：是常量，默认修饰public static final 成员方法：都是抽象方法，都有默认修饰public abstract 构造方法 ： 无 C 抽象类中定义的是继承体系中的共性功能 接口中定义的是继承体系中的扩展功能 注意事项 接口不能创建对象，没有构造方法 如果多个接口中有同名的抽象方法，重写一次就好了 如果多个接口中有同名的默认方法，必须重写这个默认方法 如果父类中的普通方法和接口中的默认方法同名，就近原则 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283关键字 super 1.可以用在类方法和对象方法中。 2.super必须在子类构造方法的第一行 3..在对象方法中可以使用super 关键字，调用当前对象从父类继承过来的对象方法。 4.super 特指这个方法是从父类继承过来的/super是指当前类或者对象的这个方法是从父 类继承过来的 this 1.代表本类对象的一个引用，谁调用this所在的方法，this就代表谁 2.使用场景 用于区分同名成员变量和局部变量 在定义函数时，该函数内部要用到该函数的对象时，因为此时对象还没有建立，this 可以代表此对象 构造函数时调用，this(参数)必须放在第一行 final 最终，可以用来修饰类，方法，变量 final修饰的类不能被继承 父类的private成员方法是不能被子类方法覆盖的，因为private类型的方法默认是final 类型 final修饰的方法不能被重写 final修饰的变量是一个常量只能被赋值一次 内部类只能访问被final修饰的局部变量 final不能用于修饰构造方法 内部类 将一个类A定义在另一个类B里面，里面的那个类A就称为内部类，B则称为外部类。 特点 内部类可以直接访问外部类的成员，包括私有成员。 外部类要访问内部类的成员，必须要建立内部类的对象 创建内部类对象格式 外部类名.内部类名 对象名 = new 外部类型().new 内部类型()； static 静态的，用来修饰成员变量和成员函数 静态的特点 随着类的加载而加载 优先于对象存在 所有对象共享 可以直接被调用 静态的注意事项 静态方法只能访问静态成员 静态方法中不能使用this，super关键字 主方法是静态的 public static void main(String[] args) public : 公共 最大的权限修饰符 static ： 由于JVM调用main方法的时候，没有创建对象，只能通过类名调用 void ： 由于main方法是被JVM调用，不需要返回值 String[] ： 字符串数组 args ： 数组名 静态变量和成员变量的区别 调用方式 静态变量也被称为类变量，可以直接通过类名调用，也可以通过对象名调用，这个变 量属于类 成员变量也称为实例变量，只能通过对象名调用 存储位置 静态变量存储在方法区的静态区 成员量存储在堆内存 局部变量存储在栈内存 生命周期 静态变量随着类的加载而醋在吗随着类的消失而消失，生命周期长 成员变量随着对象的创建而存在，随着对象的消失而消失 与对象的相关性 静态变量是所有对象共享的数据 成员变量是每个对象所特有的数据 静态的优势与弊端 优势 对对象的共享数据进行单独空间的存储，节省内存，不需要每个对象都存储一份 可以直接被类名调用 弊端 生命周期过长，随着类的消失而消失 访问出现权限，静态只能访问静态 什么时候使用静态 当所有对象共享某个数据的时候，就把这个成员变量定义为静态修饰变量 当某个方法没有访问该类中的非静态成员，就把这个方法定义为静态修饰 静态代码块 它只执行一次，比main先执行 执行顺序：静态代码块——构造代码块——构造方法 多态 概念 多态指的是编译器（申明变量时）和运行期（创建对象后）表现为不同的形态（数据类 型） 多态的前提 1、继承的存在(继承是多态的基础,没有继承就没有多态) 2、子类重写父类的方法(多态下调用子类重写的方法) 3、父类引用变量指向子类对象(子类到父类的类型转换) 对象调用成员的特点 Fu fu = new Zi(); 成员变量 编译看左边，运行看右边 成员方法 编译看左边，运行看右边 静态方法 编译看左边，运行看左边 如果参数列表是 基本数据类型, 那么传入的就是该类型的 值 如果参数列表是 类 , 那么传入的就是该类的 对象 如果参数列表是 抽象类或者是接口, 那么传入的是他们的 子类对象 参数列表是一个类/接口, 我们可以传入 它们的 子类对象 榨汁机案例 public abstract class Fruit { // 榨汁 public abstract void juice(); } public class Apple extends Fruit { @Override public void juice() { System.out.println(&quot;榨出了一杯苹果汁!~&quot;); } } public class Banana extends Fruit{ @Override public void juice() { System.out.println(&quot;榨出了一杯香蕉汁!~&quot;); } } public class WaterMelon extends Fruit { @Override public void juice() { System.out.println(&quot;榨出了一杯西瓜汁!~&quot;); } } public class Demo { public static void main(String[] args) { Apple a = new Apple(); juicer(a); Banana b = new Banana(); juicer(b); WaterMelon wm = new WaterMelon(); juicer(wm); } public static void juicer(Fruit f) { // Fruit f = new Apple(); f.juice(); } } 好处和弊端 好处 多态的存在提高了程序的扩展性和后期可维护性 弊端 多态不能直接使用子类特有的属性和行为 解决弊端的方法 向下转型(强制类型转换) 1.instanceof(判断) 给引用变量做类型的校验 变量名 instanceof 数据类型 如果变量属于该数据类型，返回true。 如果变量不属于该数据类型，返回false。 2.子类类型 变量名 = (子类类型) 父类变量名; 笔记本案例 进行描述笔记本类，实现笔记本使用USB鼠标、USB键盘 USB 接口，包含开启功能、关闭功能 笔记本类，包含运行功能、关机功能、使用 USB设备功能 鼠标类，要实现 USB接口，并具备点击的方法 键盘类，要实现 USB接口，具备敲击的方法 // USB接口 public interface USB { // 插入功能, 开启 public abstract void open(); // 拔出功能, 关闭 public abstract void close(); } public class Mouse implements USB { @Override public void open() { System.out.println(&quot;插上了鼠标&quot;); } public void click() { System.out.println(&quot;点击鼠标, 玩游戏&quot;); } @Override public void close() { System.out.println(&quot;拔出了鼠标&quot;); } } public class Keyboard implements USB{ @Override public void open() { System.out.println(&quot;插上了键盘&quot;); } public void type() { System.out.println(&quot;敲击键盘, 写代码&quot;); } @Override public void close() { System.out.println(&quot;拔出了键盘&quot;); } } /* 笔记本类 */ public class Laptop { public void start() { System.out.println(&quot;笔记本电脑开机&quot;); } // 使用USB设备 public void useUSBDevice(USB usb) { // USB usb = new Mouse(); usb.open(); // 由于多态进行了向上转型, 所以不能直接使用子类特有的属性和行为 // 想使用, 需要先向下转型 // 如果是鼠标类, 就转换成鼠标 if (usb instanceof Mouse) { ((Mouse) usb).click(); }else if (usb instanceof Keyboard) { ((Keyboard) usb).type(); } usb.close(); } public void stop() { System.out.println(&quot;笔记本电脑关机&quot;); } } public class Demo { public static void main(String[] args) { Laptop l = new Laptop(); // 创建鼠标对象 Mouse m = new Mouse(); // 创建键盘对象 Keyboard k = new Keyboard(); l.start(); // 使用usb设备 l.useUSBDevice(m); l.useUSBDevice(k); l.stop(); } }]]></content>
  </entry>
  <entry>
    <title></title>
    <url>%2F2019%2F05%2F28%2Fjava%E5%B8%B8%E7%94%A8API%2F</url>
    <content type="text"><![CDATA[title: JAVA常用APIdate: 2019-05-02 22:46:07tags: java常用API java常用APIscanner类12345678910111213141516171819Scanner(键盘录入)的使用步骤 1. 导包: import java.util.Scanner 2. 创建对象: Scanner sc = new Scanner(System.in); 3. 使用对象: sc.nextInt(); Demo: //1. 导包 import java.util.Scanner; public class Demo01_Scanner &#123; public static void main(String[] args) &#123; //2. 创建键盘录入数据的对象 Scanner sc = new Scanner(System.in); //3. 接收数据 System.out.println(&quot;请录入一个整数：&quot;); int i = sc.nextInt(); //4. 输出数据 System.out.println(&quot;i:&quot;+i); &#125; &#125; Random类Random(获取随机数)使用步骤 1. 导包: import java.util.Random 2.创建对象：Random ran = new Random（）； 3.使用对象：int r = ran.nextInt(范围); Demo: //1. 导包 import java.util.Random; public class Demo01_Random { public static void main(String[] args) { //2. 创建键盘录入数据的对象 Random r = new Random(); for(int i = 0; i &lt; 3; i++){ //3. 随机生成一个数据 int number = r.nextInt(10); //4. 输出数据 System.out.println(&quot;number:&quot;+ number); } } } ArrayList类概念:大小可变的数组 特点:长度可变的 创建集合和泛型 ArrayList&lt;泛型&gt; list = new ArrayList&lt;&gt;(); 常用功能 add（元素） 增加元素 remove（索引） 删除元素 set（索引，“改成的值”） 修改元素 get（索引） 获取元素 size（） 集合长度 集合遍历 Demo: public class Demo01ArrayListMethod { public static void main(String[] args) { //创建集合对象 ArrayList&lt;String&gt; list = new ArrayList&lt;String&gt;(); //添加元素 list.add(&quot;hello&quot;); list.add(&quot;world&quot;); list.add(&quot;java&quot;); //public E get(int index):返回指定索引处的元素 System.out.println(&quot;get:&quot;+list.get(0)); System.out.println(&quot;get:&quot;+list.get(1)); System.out.println(&quot;get:&quot;+list.get(2)); //public int size():返回集合中的元素的个数 System.out.println(&quot;size:&quot;+list.size()); //public E remove(int index):删除指定索引处的元素，返回被删除的元素 System.out.println(&quot;remove:&quot;+list.remove(0)); //遍历输出 for(int i = 0; i &lt; list.size(); i++){ System.out.println(list.get(i)); } } } Arrays类概念：用来操作数组的工具类 常用方法: toString() 返回指定数组内容的字符串表示形式。 sort() 对指定的 int 型数组按数字升序进行排序 Math类概念：用于执行基本数学运算的工具类，如初等指数、对数、平方根和三角函数 常用方法 floor() 返回小于等于参数最大的整数。 ceil() 返回大于等于参数的最小的整数。 round() 返回最接近参数的 long。(相当于四舍五入方法) xxxValue() 将 Number 对象转换为xxx数据类型的值并返回。 valueOf() 返回一个 Number 对象指定的内置数据类型 parseInt() 将字符串解析为int类型。 abs() 返回参数的绝对值。 random() 返回一个随机数。 pow() 返回第一个参数的第二个参数次方。 String类概念 用于检查各个字符串的方法，比如用于比较字符串，搜索字符串，提取子字符串以及创建具有翻 译为大写或小写的所有字符的字符串的工具类 特点 1. 字符串字面值就是一个字符串对象, 可以调用String的方法 2. 字符串是常量, 它是一个不可变的字符序列 构造方法 String() 不是使用前面的构造, 而是使用下面的方式String s = &quot;&quot;; String(String) 不是使用前面的构造, 而是使用下面的方式String s = &quot;abc&quot;; String(byte[]) 将字节数组通过编码表转换成对应的字符，然后将字符拼接起来 String(char[]) 将字符数组转换成字符串 常用方法 char charAt(索引) 获取指定索引处的字符 int compareTo(String anotherString) 按字典顺序比较两个字符串。 String concat(String str) 将指定字符串连接到此字符串的结尾。 boolean equals(Object anObject) 将此字符串与指定的对象比较。 ==： 基本数据类型中比较的是值，引用数据类型比较的是地址值 boolean equalslgnoreCase(String anotherString) 将此字符串与指定的对象比较，忽略大小写 byte[] getBytes() 使用平台的默认字符集将此 String 编码为 byte 序列，并将结果存储到一个新的 byte 数组中。 int hashCode() 返回此字符串的哈希码。 int indexOf(String str) 返回指定子字符串在此字符串中第一次出现处的索引。 String intern() 返回字符串对象的规范化表示形式。 int lastIndexOf(int ch) 返回指定字符在此字符串中最后一次出现处的索引。 int length() 返回此字符串的长度。 String replace(char oldChar, char newChar) 返回一个新的字符串，它是通过用 newChar 替换此字符串中出现的所有 oldChar 得到 的。 String replaceAll(String regex, String replacement 使用给定的 replacement 替换此字符串所有匹配给定的正则表达式的子字符串。 String[] split(String regex) 根据给定正则表达式的匹配拆分此字符串。 boolean startsWith(String prefix) 测试此字符串是否以指定的前缀开始。 String substring(int beginIndex) 截取，从开始索引到结尾，返回一个新的字符串，它是此字符串的一个子字符串。 String substring(int beginIndex, int endIndex) 从开始索引，截取到结束索引(包头不包尾),返回一个新字符串，它是此字符串的一个子字 符串。 char[] toCharArray() 将此字符串转换为一个新的字符数组。 String trim() 返回字符串的副本，忽略前导空白和尾部空白。 Demo 键盘录入一个字符，统计字符串中大小写字母及数字字符个数 public class StringTest { public static void main(String[] args) { //键盘录入一个字符串数据 Scanner sc = new Scanner(System.in); System.out.println(&quot;请输入一个字符串数据：&quot;); String s = sc.nextLine(); //定义三个统计变量，初始化值都是0 int bigCount = 0; int smallCount = 0; int numberCount = 0; //遍历字符串，得到每一个字符 for(int x=0; x&lt;s.length(); x++) { char ch = s.charAt(x); //拿字符进行判断 if(ch&gt;=&apos;A&apos;&amp;&amp;ch&lt;=&apos;Z&apos;) { bigCount++; }else if(ch&gt;=&apos;a&apos;&amp;&amp;ch&lt;=&apos;z&apos;) { smallCount++; }else if(ch&gt;=&apos;0&apos;&amp;&amp;ch&lt;=&apos;9&apos;) { numberCount++; }else { System.out.println(&quot;该字符&quot;+ch+&quot;非法&quot;); } } //输出结果 System.out.println(&quot;大写字符：&quot;+bigCount+&quot;个&quot;); System.out.println(&quot;小写字符：&quot;+smallCount+&quot;个&quot;); System.out.println(&quot;数字字符：&quot;+numberCount+&quot;个&quot;); } } StringBuffer 和 StringBuilder 类与String类区别 StringBuffer 和 StringBuilder 类的对象能够被多次的修改，并且不产生新的未使用对象 StringBuffer与StringBuilder区别 StringBuffer的方法是线程安全的（不能同步访问） StringBuilder 相较于 StringBuffer 有速度优势 常用方法 public StringBuffer append(String s) 将指定的字符串追加到此字符序列。 public StringBuffer reverse() 将此字符序列用其反转形式取代。 public delete(int start, int end) 移除此序列的子字符串中的字符。 public insert(int offset, int i) 将 int 参数的字符串表示形式插入此序列中。 replace(int start, int end, String str) 使用给定 String 中的字符替换此序列的子字符串中的字符。 Object类概念 Object类是所有类(数组)的父类, 所有的类都直接或者间接的继承自Object 常用方法 public String toString() ：返回该对象的字符串表示。 没有意义, Object的子类一般会重写toString(), 重写之后会打印属性值 public boolean equals(Object obj) ：指示其他某个对象是否与此对象“相等”。 equals(): 底层使用的就是==, 比较的是地址值.没有意义, 一般会重写equals方法, 重写之后比较的是属性值 == : 基本数据类型比较的是值, 如果是引用数据类型比较地址值 System类概念 获取与系统相关的信息或系统级操作的工具类 常用方法 public static long currentTimeMillis() ：返回以毫秒为单位的当前时间。 public static void exit() : 退出Java虚拟机 public static void arraycopy(Object src, int srcPos, Object dest, int destPos, int length) ：将数组中指定的数据拷贝到另一个数组中。 Object src : 原数组 int srcPos : 从原数组的那个索引开始拷贝 Object dest : 目的数组 int destPos : 从目的数组的那个索引开始拷贝 int length : 拷贝的长度(个数) 时间日期类1、Date类(时间类） 构造方法 public Date() ：分配Date对象并初始化此对象，以表示分配它的时间（精确到毫秒）。 ublic Date(long date) ：分配Date对象并初始化此对象，以表示自从标准基准时间 （称为“历元（epoch）”，即1970年1月1日00:00:00 GMT）以来的指定毫秒数。 常用方法 boolean after(Date date) 若当调用此方法的Date对象在指定日期之后返回true,否则返回false。 boolean before(Date date) 若当调用此方法的Date对象在指定日期之前返回true,否则返回false。 int compareTo(Date date) 比较当调用此方法的Date对象和指定日期。两者相等时候返回0。调用对象在指定日期 之前则返回负数。调用对象在指定日期之后则返回正数。 long getTime( ) 返回自 1970 年 1 月 1 日 00:00:00 GMT 以来此 Date 对象表示的毫秒数。 String toString( ) 转换Date对象为String表示形式，并返回该字符串。 Demo public class DateTest { public static void main(String[] args) { // 创建日期对象，获取当前的时间 System.out.println(new Date()); // 创建日期对象，获取初始时间 System.out.println(new Date(0L));//Thu Jan 01 08:00:00 CST 1970 //创建日期对象，获取当前的时间的毫秒值 System.out.println(new Date().getTime()); // 若当调用此方法的Date对象在指定日期之后返回true,否则返回false。 System.out.println(new Date().after(new Date(1L))); //若当调用此方法的Date对象在指定日期之前返回true,否则返回false。 System.out.println(new Date().before(new Date(100L))); //比较当调用此方法的Date对象和指定日期。两者相等时候返回0。 //调用对象在指定日期之前则返回负数。在指定日期之后则返回正数。 System.out.println(new Date().compareTo(new Date())); //转换Date对象为String表示形式，并返回该字符串。 System.out.println(new Date().toString()); } } 2、DateFormat类(日期/时间格式化) 格式化 ：按照指定的格式，从Date对象转换为String对象。 解析 ：按照指定的格式，从String对象转换为Date对象。 构造方法 public SimpleDateFormat(String pattern) ：用给定的模式和默认语言环境的日期 格式符号构造SimpleDateFormat。 常用方法 public String format(Date date) ：将Date对象格式化为字符串。 public Date parse(String source) ：将字符串解析为Date对象。 Demo 计算出一个人已经出生了多少天。 public class DateTest1 { public static void main(String[] args) throws Exception { function(); } public static void function() throws Exception { //获取出生日期 System.out.println(&quot;请输入出生日期 格式 YYYY-MM-dd&quot;); String birthday = new Scanner(System.in).nextLine(); // 将字符串日期,转成Date对象 // 创建SimpleDateFormat对象,写日期模式 SimpleDateFormat simpleDateFormat = new SimpleDateFormat(&quot;yyyy- MM-dd&quot;); // 调用方法parse,字符串转成日期对象 Date birthdayDate = simpleDateFormat.parse(birthday); //获取今天的日期对象 Date today = new Date(); //将出生日期转换为毫秒数 long birthdayDateTime = birthdayDate.getTime(); //将今天的日期转换为毫秒数 long todayTime = today.getTime(); //今天的毫秒数减去出生日期的毫秒数 long secone = todayTime - birthdayDateTime; if (secone &lt; 0 ){ System.out.println(&quot;还没出生呢&quot;); }else { System.out.println(secone/1000/60/60/24); } } } 3、Calendar类(日历类) Calendar静态方法 public static Calendar getInstance() ：使用默认时区和语言环境获得一个日历 Calendar创建对象 Calendar c = Calendar.getInstance(); 常用方法 public static Calendar getInstance() ：使用默认时区和语言环境获得一个日历 public int get(int field) ：返回给定日历字段的值。 public void set(int field, int value) ：将给定的日历字段设置为给定值。 public abstract void add(int field, int amount) ：根据日历的规则，为给定的 日历字段添加或减去指定的时间量。 public Date getTime() ：返回一个表示此Calendar时间值（从历元到现在的毫秒偏移 量）的Date对象。 ​]]></content>
  </entry>
  <entry>
    <title></title>
    <url>%2F2019%2F05%2F05%2Fjava%E5%85%A5%E9%97%A8%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title></title>
    <url>%2F2019%2F04%2F20%2FJAVA%E7%AE%80%E4%BB%8B%2F</url>
    <content type="text"><![CDATA[title: JAVA简介date: 2019-05-02 22:46:07tags: java简介JAVA介绍 Java是由Sun Microsystems公司于1995年5月推出的Java面向对象程序设计语言和Java平台的总称。由James Gosling和同事们共同研发，并在1995年正式推出。 Java分为三个体系： JavaSE（J2SE）（Java2 Platform Standard Edition，java平台标准版） JavaEE(J2EE)(Java 2 Platform,Enterprise Edition，java平台企业版) JavaME(J2ME)(Java 2 Platform Micro Edition，java平台微型版)。 JAVA特性 Java语言是简单的 Java语言的语法与C语言和C++语言很接近，使得大多数程序员很容易学习和使用。另一方面，Java丢弃了C++中很少使用的、很难理解的、令人迷惑的那些特性，如操作符重载、多继承、自动的强制类型转换。特别地，Java语言不使用指针，而是引用。并提供了自动的废料收集，使得程序员不必为内存管理而担忧。 Java语言是面向对象的 &emsp;Java语言提供类、接口和继承等面向对象的特性，为了简单起见，只支持类之间的单继承，但支持接口之间的多继承，并支持类与接口之间的实现机制（关键字为implements）。Java语言全面支持动态绑定，而C++语言只对虚函数使用动态绑定。总之，Java语言是一个纯的面向对象程序设计语言。 Java语言是分布式的 &emsp;Java语言支持Internet应用的开发，在基本的Java应用编程接口中有一个网络应用编程接口（java net），它提供了用于网络应用编程的类库，包括URL、URLConnection、Socket、ServerSocket等。Java的RMI（远程方法激活）机制也是开发分布式应用的重要手段。 Java语言是健壮的 &emsp;Java的强类型机制、异常处理、垃圾的自动收集等是Java程序健壮性的重要保证。对指针的丢弃是Java的明智选择。Java的安全检查机制使得Java更具健壮性。 Java语言是安全的 &emsp;Java通常被用在网络环境中，为此，Java提供了一个安全机制以防恶意代码的攻击。除了Java语言具有的许多安全特性以外，Java对通过网络下载的类具有一个安全防范机制（类ClassLoader），如分配不同的名字空间以防替代本地的同名类、字节代码检查，并提供安全管理机制（类SecurityManager）让Java应用设置安全哨兵。 Java语言是体系结构中立的 &emsp;Java程序（后缀为java的文件）在Java平台上被编译为体系结构中立的字节码格式（后缀为class的文件），然后可以在实现这个Java平台的任何系统中运行。这种途径适合于异构的网络环境和软件的分发。 Java语言是可移植的 &emsp;这种可移植性来源于体系结构中立性，另外，Java还严格规定了各个基本数据类型的长度。Java系统本身也具有很强的可移植性，Java编译器是用Java实现的，Java的运行环境是用ANSI C实现的。 Java语言是解释型的 &emsp;如前所述，Java程序在Java平台上被编译为字节码格式，然后可以在实现这个Java平台的任何系统中运行。在运行时，Java平台中的Java解释器对这些字节码进行解释执行，执行过程中需要的类在联接阶段被载入到运行环境中。 Java是高性能的 &emsp;与那些解释型的高级脚本语言相比，Java的确是高性能的。事实上，Java的运行速度随着JIT(Just-In-Time）编译器技术的发展越来越接近于C++。 Java语言是多线程的 &emsp;在Java语言中，线程是一种特殊的对象，它必须由Thread类或其子（孙）类来创建。通常有两种方法来创建线程：其一，使用型构为Thread(Runnable)的构造子类将一个实现了Runnable接口的对象包装成一个线程，其二，从Thread类派生出子类并重写run方法，使用该子类创建的对象即为线程。值得注意的是Thread类已经实现了Runnable接口，因此，任何一个线程均有它的run方法，而run方法中包含了线程所要运行的代码。线程的活动由一组方法来控制。Java语言支持多个线程的同时执行，并提供多线程之间的同步机制（关键字为synchronized）。 Java语言是动态的 Java语言的设计目标之一是适应于动态变化的环境。Java程序需要的类能够动态地被载入到运行环境，也可以通过网络来载入所需要的类。这也有利于软件的升级。另外，Java中的类有一个运行时刻的表示，能进行运行时刻的类型检查。 JDK下载与环境变量配置 百度]]></content>
  </entry>
</search>
