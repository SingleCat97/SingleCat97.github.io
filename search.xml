<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[JAVA常用API]]></title>
    <url>%2F2019%2F05%2F28%2FJAVA%E5%B8%B8%E7%94%A8API%2F</url>
    <content type="text"><![CDATA[java常用API java常用APIscanner类12345678910111213141516171819Scanner(键盘录入)的使用步骤 1. 导包: import java.util.Scanner 2. 创建对象: Scanner sc = new Scanner(System.in); 3. 使用对象: sc.nextInt(); Demo: //1. 导包 import java.util.Scanner; public class Demo01_Scanner &#123; public static void main(String[] args) &#123; //2. 创建键盘录入数据的对象 Scanner sc = new Scanner(System.in); //3. 接收数据 System.out.println(&quot;请录入一个整数：&quot;); int i = sc.nextInt(); //4. 输出数据 System.out.println(&quot;i:&quot;+i); &#125; &#125; Random类1234567891011121314151617181920Random(获取随机数)使用步骤 1. 导包: import java.util.Random 2.创建对象：Random ran = new Random（）； 3.使用对象：int r = ran.nextInt(范围);Demo: //1. 导包 import java.util.Random; public class Demo01_Random &#123; public static void main(String[] args) &#123; //2. 创建键盘录入数据的对象 Random r = new Random(); for(int i = 0; i &lt; 3; i++)&#123; //3. 随机生成一个数据 int number = r.nextInt(10); //4. 输出数据 System.out.println(&quot;number:&quot;+ number); &#125; &#125; &#125; ArrayList类1概念:大小可变的数组 1特点:长度可变的 123456789101112131415161718192021222324252627282930313233343536373839创建集合和泛型 ArrayList&lt;泛型&gt; list = new ArrayList&lt;&gt;();常用功能 add（元素） 增加元素 remove（索引） 删除元素 set（索引，“改成的值”） 修改元素 get（索引） 获取元素 size（） 集合长度 集合遍历Demo: public class Demo01ArrayListMethod &#123; public static void main(String[] args) &#123; //创建集合对象 ArrayList&lt;String&gt; list = new ArrayList&lt;String&gt;(); //添加元素 list.add(&quot;hello&quot;); list.add(&quot;world&quot;); list.add(&quot;java&quot;); //public E get(int index):返回指定索引处的元素 System.out.println(&quot;get:&quot;+list.get(0)); System.out.println(&quot;get:&quot;+list.get(1)); System.out.println(&quot;get:&quot;+list.get(2)); //public int size():返回集合中的元素的个数 System.out.println(&quot;size:&quot;+list.size()); //public E remove(int index):删除指定索引处的元素，返回被删除的元素 System.out.println(&quot;remove:&quot;+list.remove(0)); //遍历输出 for(int i = 0; i &lt; list.size(); i++)&#123; System.out.println(list.get(i)); &#125; &#125; &#125; Arrays类1概念：用来操作数组的工具类 12345常用方法:toString() 返回指定数组内容的字符串表示形式。sort() 对指定的 int 型数组按数字升序进行排序 Math类1概念：用于执行基本数学运算的工具类，如初等指数、对数、平方根和三角函数 12345678910111213141516171819常用方法floor() 返回小于等于参数最大的整数。ceil() 返回大于等于参数的最小的整数。round() 返回最接近参数的 long。(相当于四舍五入方法)xxxValue() 将 Number 对象转换为xxx数据类型的值并返回。valueOf() 返回一个 Number 对象指定的内置数据类型parseInt() 将字符串解析为int类型。abs() 返回参数的绝对值。random() 返回一个随机数。pow() 返回第一个参数的第二个参数次方。 String类1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192概念 用于检查各个字符串的方法，比如用于比较字符串，搜索字符串，提取子字符串以及创建具有翻译为大写或小写的所有字符的字符串的工具类特点 1. 字符串字面值就是一个字符串对象, 可以调用String的方法 2. 字符串是常量, 它是一个不可变的字符序列 构造方法 String() 不是使用前面的构造, 而是使用下面的方式String s = &quot;&quot;; String(String) 不是使用前面的构造, 而是使用下面的方式String s = &quot;abc&quot;; String(byte[]) 将字节数组通过编码表转换成对应的字符，然后将字符拼接起来 String(char[]) 将字符数组转换成字符串 常用方法 char charAt(索引) 获取指定索引处的字符 int compareTo(String anotherString) 按字典顺序比较两个字符串。 String concat(String str) 将指定字符串连接到此字符串的结尾。 boolean equals(Object anObject) 将此字符串与指定的对象比较。 ==： 基本数据类型中比较的是值，引用数据类型比较的是地址值 boolean equalslgnoreCase(String anotherString) 将此字符串与指定的对象比较，忽略大小写 byte[] getBytes() 使用平台的默认字符集将此 String 编码为 byte 序列，并将结果存储到一个新的 byte 数组中。 int hashCode() 返回此字符串的哈希码。 int indexOf(String str) 返回指定子字符串在此字符串中第一次出现处的索引。 String intern() 返回字符串对象的规范化表示形式。 int lastIndexOf(int ch) 返回指定字符在此字符串中最后一次出现处的索引。 int length() 返回此字符串的长度。 String replace(char oldChar, char newChar) 返回一个新的字符串，它是通过用 newChar 替换此字符串中出现的所有 oldChar 得到 的。 String replaceAll(String regex, String replacement 使用给定的 replacement 替换此字符串所有匹配给定的正则表达式的子字符串。 String[] split(String regex) 根据给定正则表达式的匹配拆分此字符串。 boolean startsWith(String prefix) 测试此字符串是否以指定的前缀开始。 String substring(int beginIndex) 截取，从开始索引到结尾，返回一个新的字符串，它是此字符串的一个子字符串。 String substring(int beginIndex, int endIndex) 从开始索引，截取到结束索引(包头不包尾),返回一个新字符串，它是此字符串的一个子字 符串。 char[] toCharArray() 将此字符串转换为一个新的字符数组。 String trim() 返回字符串的副本，忽略前导空白和尾部空白。 Demo 键盘录入一个字符，统计字符串中大小写字母及数字字符个数 public class StringTest &#123; public static void main(String[] args) &#123; //键盘录入一个字符串数据 Scanner sc = new Scanner(System.in); System.out.println(&quot;请输入一个字符串数据：&quot;); String s = sc.nextLine(); //定义三个统计变量，初始化值都是0 int bigCount = 0; int smallCount = 0; int numberCount = 0; //遍历字符串，得到每一个字符 for(int x=0; x&lt;s.length(); x++) &#123; char ch = s.charAt(x); //拿字符进行判断 if(ch&gt;=&apos;A&apos;&amp;&amp;ch&lt;=&apos;Z&apos;) &#123; bigCount++; &#125;else if(ch&gt;=&apos;a&apos;&amp;&amp;ch&lt;=&apos;z&apos;) &#123; smallCount++; &#125;else if(ch&gt;=&apos;0&apos;&amp;&amp;ch&lt;=&apos;9&apos;) &#123; numberCount++; &#125;else &#123; System.out.println(&quot;该字符&quot;+ch+&quot;非法&quot;); &#125; &#125; //输出结果 System.out.println(&quot;大写字符：&quot;+bigCount+&quot;个&quot;); System.out.println(&quot;小写字符：&quot;+smallCount+&quot;个&quot;); System.out.println(&quot;数字字符：&quot;+numberCount+&quot;个&quot;); &#125; &#125; StringBuffer 和 StringBuilder 类123456789101112131415161718与String类区别 StringBuffer 和 StringBuilder 类的对象能够被多次的修改，并且不产生新的未使用对象StringBuffer与StringBuilder区别 StringBuffer的方法是线程安全的（不能同步访问） StringBuilder 相较于 StringBuffer 有速度优势常用方法 public StringBuffer append(String s) 将指定的字符串追加到此字符序列。 public StringBuffer reverse() 将此字符序列用其反转形式取代。 public delete(int start, int end) 移除此序列的子字符串中的字符。 public insert(int offset, int i) 将 int 参数的字符串表示形式插入此序列中。 replace(int start, int end, String str) 使用给定 String 中的字符替换此序列的子字符串中的字符。 Object类123456789概念 Object类是所有类(数组)的父类, 所有的类都直接或者间接的继承自Object常用方法 public String toString() ：返回该对象的字符串表示。 没有意义, Object的子类一般会重写toString(), 重写之后会打印属性值 public boolean equals(Object obj) ：指示其他某个对象是否与此对象“相等”。 equals(): 底层使用的就是==, 比较的是地址值.没有意义, 一般会重写equals方法, 重写之后比较的是属性值 == : 基本数据类型比较的是值, 如果是引用数据类型比较地址值 System类1234567891011121314概念 获取与系统相关的信息或系统级操作的工具类常用方法 public static long currentTimeMillis() ：返回以毫秒为单位的当前时间。 public static void exit() : 退出Java虚拟机 public static void arraycopy(Object src, int srcPos, Object dest, int destPos, int length) ：将数组中指定的数据拷贝到另一个数组中。 Object src : 原数组 int srcPos : 从原数组的那个索引开始拷贝 Object dest : 目的数组 int destPos : 从目的数组的那个索引开始拷贝 int length : 拷贝的长度(个数) 时间日期类12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394951、Date类(时间类） 构造方法 public Date() ：分配Date对象并初始化此对象，以表示分配它的时间（精确到毫秒）。 ublic Date(long date) ：分配Date对象并初始化此对象，以表示自从标准基准时间 （称为“历元（epoch）”，即1970年1月1日00:00:00 GMT）以来的指定毫秒数。 常用方法 boolean after(Date date) 若当调用此方法的Date对象在指定日期之后返回true,否则返回false。 boolean before(Date date) 若当调用此方法的Date对象在指定日期之前返回true,否则返回false。 int compareTo(Date date) 比较当调用此方法的Date对象和指定日期。两者相等时候返回0。调用对象在指定日期 之前则返回负数。调用对象在指定日期之后则返回正数。 long getTime( ) 返回自 1970 年 1 月 1 日 00:00:00 GMT 以来此 Date 对象表示的毫秒数。 String toString( ) 转换Date对象为String表示形式，并返回该字符串。 Demo public class DateTest &#123; public static void main(String[] args) &#123; // 创建日期对象，获取当前的时间 System.out.println(new Date()); // 创建日期对象，获取初始时间 System.out.println(new Date(0L));//Thu Jan 01 08:00:00 CST 1970 //创建日期对象，获取当前的时间的毫秒值 System.out.println(new Date().getTime()); // 若当调用此方法的Date对象在指定日期之后返回true,否则返回false。 System.out.println(new Date().after(new Date(1L))); //若当调用此方法的Date对象在指定日期之前返回true,否则返回false。 System.out.println(new Date().before(new Date(100L))); //比较当调用此方法的Date对象和指定日期。两者相等时候返回0。 //调用对象在指定日期之前则返回负数。在指定日期之后则返回正数。 System.out.println(new Date().compareTo(new Date())); //转换Date对象为String表示形式，并返回该字符串。 System.out.println(new Date().toString()); &#125; &#125; 2、DateFormat类(日期/时间格式化) 格式化 ：按照指定的格式，从Date对象转换为String对象。 解析 ：按照指定的格式，从String对象转换为Date对象。 构造方法 public SimpleDateFormat(String pattern) ：用给定的模式和默认语言环境的日期 格式符号构造SimpleDateFormat。 常用方法 public String format(Date date) ：将Date对象格式化为字符串。 public Date parse(String source) ：将字符串解析为Date对象。 Demo 计算出一个人已经出生了多少天。 public class DateTest1 &#123; public static void main(String[] args) throws Exception &#123; function(); &#125; public static void function() throws Exception &#123; //获取出生日期 System.out.println(&quot;请输入出生日期 格式 YYYY-MM-dd&quot;); String birthday = new Scanner(System.in).nextLine(); // 将字符串日期,转成Date对象 // 创建SimpleDateFormat对象,写日期模式 SimpleDateFormat simpleDateFormat = new SimpleDateFormat(&quot;yyyy- MM-dd&quot;); // 调用方法parse,字符串转成日期对象 Date birthdayDate = simpleDateFormat.parse(birthday); //获取今天的日期对象 Date today = new Date(); //将出生日期转换为毫秒数 long birthdayDateTime = birthdayDate.getTime(); //将今天的日期转换为毫秒数 long todayTime = today.getTime(); //今天的毫秒数减去出生日期的毫秒数 long secone = todayTime - birthdayDateTime; if (secone &lt; 0 )&#123; System.out.println(&quot;还没出生呢&quot;); &#125;else &#123; System.out.println(secone/1000/60/60/24); &#125; &#125; &#125;3、Calendar类(日历类) Calendar静态方法 public static Calendar getInstance() ：使用默认时区和语言环境获得一个日历 Calendar创建对象 Calendar c = Calendar.getInstance(); 常用方法 public static Calendar getInstance() ：使用默认时区和语言环境获得一个日历 public int get(int field) ：返回给定日历字段的值。 public void set(int field, int value) ：将给定的日历字段设置为给定值。 public abstract void add(int field, int amount) ：根据日历的规则，为给定的 日历字段添加或减去指定的时间量。 public Date getTime() ：返回一个表示此Calendar时间值（从历元到现在的毫秒偏移 量）的Date对象。 ​]]></content>
  </entry>
  <entry>
    <title><![CDATA[JAVA简介]]></title>
    <url>%2F2019%2F05%2F28%2FJAVA%E7%AE%80%E4%BB%8B%2F</url>
    <content type="text"><![CDATA[java简介JAVA介绍 Java是由Sun Microsystems公司于1995年5月推出的Java面向对象程序设计语言和Java平台的总称。由James Gosling和同事们共同研发，并在1995年正式推出。 Java分为三个体系： JavaSE（J2SE）（Java2 Platform Standard Edition，java平台标准版） JavaEE(J2EE)(Java 2 Platform,Enterprise Edition，java平台企业版) JavaME(J2ME)(Java 2 Platform Micro Edition，java平台微型版)。 JAVA特性 Java语言是简单的 Java语言的语法与C语言和C++语言很接近，使得大多数程序员很容易学习和使用。另一方面，Java丢弃了C++中很少使用的、很难理解的、令人迷惑的那些特性，如操作符重载、多继承、自动的强制类型转换。特别地，Java语言不使用指针，而是引用。并提供了自动的废料收集，使得程序员不必为内存管理而担忧。 Java语言是面向对象的 Java语言提供类、接口和继承等面向对象的特性，为了简单起见，只支持类之间的单继承，但支持接口之间的多继承，并支持类与接口之间的实现机制（关键字为implements）。Java语言全面支持动态绑定，而C++语言只对虚函数使用动态绑定。总之，Java语言是一个纯的面向对象程序设计语言。 Java语言是分布式的 Java语言支持Internet应用的开发，在基本的Java应用编程接口中有一个网络应用编程接口（java net），它提供了用于网络应用编程的类库，包括URL、URLConnection、Socket、ServerSocket等。Java的RMI（远程方法激活）机制也是开发分布式应用的重要手段。 Java语言是健壮的 Java的强类型机制、异常处理、垃圾的自动收集等是Java程序健壮性的重要保证。对指针的丢弃是Java的明智选择。Java的安全检查机制使得Java更具健壮性。 Java语言是安全的 Java通常被用在网络环境中，为此，Java提供了一个安全机制以防恶意代码的攻击。除了Java语言具有的许多安全特性以外，Java对通过网络下载的类具有一个安全防范机制（类ClassLoader），如分配不同的名字空间以防替代本地的同名类、字节代码检查，并提供安全管理机制（类SecurityManager）让Java应用设置安全哨兵。 Java语言是体系结构中立的 Java程序（后缀为java的文件）在Java平台上被编译为体系结构中立的字节码格式（后缀为class的文件），然后可以在实现这个Java平台的任何系统中运行。这种途径适合于异构的网络环境和软件的分发。 Java语言是可移植的 这种可移植性来源于体系结构中立性，另外，Java还严格规定了各个基本数据类型的长度。Java系统本身也具有很强的可移植性，Java编译器是用Java实现的，Java的运行环境是用ANSI C实现的。 Java语言是解释型的 如前所述，Java程序在Java平台上被编译为字节码格式，然后可以在实现这个Java平台的任何系统中运行。在运行时，Java平台中的Java解释器对这些字节码进行解释执行，执行过程中需要的类在联接阶段被载入到运行环境中。 Java是高性能的 与那些解释型的高级脚本语言相比，Java的确是高性能的。事实上，Java的运行速度随着JIT(Just-In-Time）编译器技术的发展越来越接近于C++。 Java语言是多线程的 在Java语言中，线程是一种特殊的对象，它必须由Thread类或其子（孙）类来创建。通常有两种方法来创建线程：其一，使用型构为Thread(Runnable)的构造子类将一个实现了Runnable接口的对象包装成一个线程，其二，从Thread类派生出子类并重写run方法，使用该子类创建的对象即为线程。值得注意的是Thread类已经实现了Runnable接口，因此，任何一个线程均有它的run方法，而run方法中包含了线程所要运行的代码。线程的活动由一组方法来控制。Java语言支持多个线程的同时执行，并提供多线程之间的同步机制（关键字为synchronized）。 Java语言是动态的 Java语言的设计目标之一是适应于动态变化的环境。Java程序需要的类能够动态地被载入到运行环境，也可以通过网络来载入所需要的类。这也有利于软件的升级。另外，Java中的类有一个运行时刻的表示，能进行运行时刻的类型检查。 JDK下载与环境变量配置 百度]]></content>
  </entry>
  <entry>
    <title><![CDATA[JAVA面向对象]]></title>
    <url>%2F2019%2F05%2F28%2FJAVA%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%2F</url>
    <content type="text"><![CDATA[java面向对象 面向对象概述1Java语言是一种面向对象的程序设计语言，而面向对象思想是一种程序设计思想，我们在面向对象思想的指引下，使用Java语言去设计、开发计算机程序。 这里的对象泛指现实中一切事物，每种事物都具备自己的属性和行为。面向对象思想就是在计算机程序设计过程中，参照现实中事物，将事物的属性特征、行为特征抽象出来，描述成计算机事件的设计思想。 它区别于面向过程思想，强调的是通过调用对象的行为来实现功能，而不是自己一步一步的去操作实现。 举例1234567洗衣服:面向过程：把衣服脱下来 --&gt;找一个盆--&gt;放点洗衣粉--&gt;加点水--&gt;浸泡10分钟--&gt;揉一揉--&gt;清洗衣服--&gt;拧干--&gt;晾起来面向对象：把衣服脱下来 --&gt;打开全自动洗衣机--&gt;扔衣服--&gt;按钮--&gt;晾起来区别 :面向过程：强调步骤。面向对象：强调对象，这里的对象就是洗衣机。 特点1231、是一种更符合人们思考习惯的思想2、将复杂的事情简单化3、将人们从执行者变成了指挥者 本质1不断的寻找对象, 创建对象, 指挥对象做事情 特征1封装，继承，多态 基本定义12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788类 对事物、逻辑、算法或概念的抽象。描述一类对象的行为和状态。对象（实例） 对象是类的一个实例（对象不是找个女朋友），有状态和行为。引用 java中，一切都“看作”对象，但操纵的标识符实际是指向一个对象的“引用”（reference）。”构造方法 新建对象时，执行的一个特殊方法 在创建一个对象的时候，至少要调用一个构造方法 构造方法的名称必须与类同名，一个类可以有多个构造方法 this 引用当前对象 构造方法之间调用方法重载overload 在子类中定义一个与父类中方法同名，同参数列表的方法 方法重写和重载的区别 重载规则：必须具有不同的参数列表； 可以有不同的返回类型；可以有不同的访问修饰 符；可以抛出不同的异常。 重写规则：参数列表必须完全与被重写的方法相同，否则不能称其为重写而是重载；返回 类型必须一直与被重写的方法相同，否则不能称其为重写而是重载；访问修饰符的限制一 定要大于等于被重写方法的访问修饰符；重写方法一定不能抛出新的检查异常或者比被重 写方法申明更加宽泛的检查型异常，譬如父类方法声明了一个检查异常 IOException，在 重写这个方法时就不能抛出 Exception，只能抛出 IOException 的子类异常，可以抛出 非检查异常。 重载与重写是 Java 多态性的不同表现。 重写是父类与子类之间多态性的表现，在运行时起作用（动态多态性，譬如实现动态绑定） 而重载是一个类中多态性的表现，在编译时起作用（静态多态性，譬如实现静态绑定）。 抽象类 作用 为子类提供通用代码 为子类提供通用方法的定义 注意点 抽象类不能创建对象 包含抽象方法的类，必须是抽象类 抽象类中，不一定有抽象方法 final 最终不可变的 修饰变量、方法、类 static（静态） 静态变量属于类，可以成为“类变量” 非静态成员属于实例 静态成员通常使用类名直接调用 被static修饰的成员将最优先加载到内存 接口 作用 结构设计工具，用来解耦合 极端的抽象类 用interface替代class 用implements替代extends 接口中只能定义 公共的常量 公共的抽象方法 公共的内部类、内部接口内部类 定义 定义在类内部，方法内部或局部代码块中的类非静态内部类 非静态内部类依赖于外部类对象存在 在非静态内部类中，不能定义静态成员静态内部类 使用static修饰的成员内部类，称之为静态内部类 静态内部类只能访问外部类的静态成员 不能直接访问外部类的非静态成员 局部内部类 定义 声明在方法内部的类 局部类型，只能在局部使用 但它的实例，可以转为父类型传递出去 注意 不可以使用任何访问权限修饰符 不可以直接访问局部变量（方法的参数等效于局部变量） 如果一定需要访问，则需要使用final对局部变量进行修饰成员内部类 在类（外部类）的内部，且与外部类的成员是“同一级别”的 匿名内部类 直接创建已知的类的子类的对象，则该对象的类型就是匿名内部类 java面对对象三大特性123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383封装 概述 将属性隐藏起来，若需要访问某个属性，提供公共方法对其访问 封装的步骤 1. 使用 private 关键字来修饰成员变量。 2. 对需要访问的成员变量，提供对应的一对 getXxx 方法 、 setXxx 方法，用于对这 些属性的存取，在赋值方法中,加入对属性的存取控制语句 访问控制符 private 成员变量和方法只能在类内被访问,具有类可见性. default 成员变量和方法只能被同一个包里的类访问,具有包可见性 protected 可以被同一个包中的类访问,被同一个项目中不同包中的子类访问 public 可以被同一个项目中所有类访问,具有项目可见性,这是最大的访问权限 private的使用格式 private 数据类型 变量名 ； 1. 使用 private 修饰成员变量，代码如下： public class Student &#123; private String name; private int age; &#125; 2. 提供 getXxx 方法 / setXxx 方法，可以访问成员变量，代码如下： public class Student &#123; private String name; private int age; public void setName(String n) &#123; name = n; &#125; public String getName() &#123; return name; &#125; public void setAge(int a) &#123; age = a; &#125; public int getAge() &#123; return age; &#125; &#125; 3.this关键字优化 上述setXxx 方法中的形参名字并不符合见名知意的规定，如果修改与成员变量 名一致，由于形参变量名与成员变量名重名，导致成员变量名会被隐藏，方法中的变量 名，无法访问到成员变量，从而赋值失败。所以，我们需要使用this关键字，来解决 这个重名问题。 this的含义 this代表所在类的当前对象的引用（地址值），即对象自己的引用。 方法被哪个对象调用，方法中的this就代表那个对象。即谁在调用，this就代 表谁。 this使用格式 this.成员变量名； 使用 this 修饰方法中的变量，解决成员变量被隐藏的问题，代码如下 public class Student &#123; private String name; private int age; public void setName(String name) &#123; this.name = name; &#125; public String getName() &#123; return name; &#125; public void setAge(int age) &#123; this.age = age; &#125; public int getAge() &#123; return age; &#125; &#125; 4.构造方法优化 当一个对象被创建时候，构造方法用来初始化该对象，给对象的成员变量赋初始值。 构造方法的定义格式 修饰符 构造方法名(参数列表)&#123; // 方法体 &#125; 构造方法的写法上，方法名与它所在的类名相同。它没有返回值，所以不需要返回值 类型，甚至不需要void。使用构造方法后，代码如下： public class Student &#123; private String name; private int age; // 无参数构造方法 public Student() &#123;&#125; // 有参数构造方法 public Student(String name,int age) &#123; this.name = name; this.age = age; &#125; &#125; 注意事项 1. 如果你不提供构造方法，系统会给出无参数构造方法。 2. 如果你提供了构造方法，系统将不再提供无参数构造方法。 3. 构造方法是可以重载的，既可以定义参数，也可以不定义参数。 5.标准代码——JavaBean JavaBean 是 Java语言编写类的一种标准规范。符合 JavaBean 的类，要求类必须 是具体的和公共的，并且具有无参数的构造方法，提供用来操作成员变量的 set 和 get 方法。 student类 public class Student &#123; //成员变量 private String name; private int age; //构造方法 public Student() &#123;&#125; public Student(String name,int age) &#123; this.name = name; this.age = age; &#125; //成员方法 publicvoid setName(String name) &#123; this.name = name; &#125; public String getName() &#123; return name; &#125; publicvoid setAge(int age) &#123; this.age = age; &#125; publicint getAge() &#123; return age; &#125; &#125; 测试类 public class TestStudent &#123; public static void main(String[] args) &#123; //无参构造使用 Student s= new Student(); s.setName(&quot;柳岩&quot;); s.setAge(18); System.out.println(s.getName()+&quot;‐‐‐&quot;+s.getAge()); //带参构造使用 Student s2= new Student(&quot;千反田&quot;,18); System.out.println(s2.getName()+&quot;‐‐‐&quot;+s2.getAge()); &#125; &#125; 封装好处 隐藏类的实现细节 让使用者只能通过程序员规定的方法来访问数据 可以方便的加入存取控制语句,限制不合理操作继承 概念 就是子类继承父类的属性和行为，使得子类对象具有与父类相同的属性、相同的行为。子 类可以直接访问父类中的非私有的属性和行为。继承通过extends关键字来实现,其中SubClass 为子类,SuperClass称为父类,基类,或超类 格式 class 父类 &#123; ... &#125; class 子类 extends 父类 &#123; ... &#125; 实例 /* * 定义员工类Employee，做为父类 */ class Employee &#123; String name; // 定义name属性 // 定义员工的工作方法 public void work() &#123; System.out.println(&quot;尽心尽力地工作&quot;); &#125; &#125; /* * 定义讲师类Teacher 继承 员工类Employee */ class Teacher extends Employee &#123; // 定义一个打印name的方法 public void printName() &#123; System.out.println(&quot;name=&quot; + name); &#125; &#125; /* * 定义测试类 */ public class ExtendDemo01 &#123; public static void main(String[] args) &#123; // 创建一个讲师类对象 Teacher t = new Teacher(); // 为该员工类的name属性进行赋值 t.name = &quot;小明&quot;; // 调用该员工的printName()方法 t.printName(); // name = 小明 // 调用Teacher类继承来的work()方法 t.work(); // 尽心尽力地工作 &#125; &#125; 作用 代码重用，代码复用 单继承 一个类，只能继承一个父类 一个类，可以有多个子类 不继承 构造方法不继承 没有访问权限的成员不继承 静态成员不继承 子父类中的成员关系 成员变量 1.在方法的局部变量中寻找，有则使用 2.在本类的成员变量中寻找，有则使用 3.在父类的成员变量中寻找，有则使用 4.都没有，报错 成员方法 1.在子类中寻找，有则使用 2.在父类中寻找，有则使用 3.没有，报错 构造方法 子类的初始化过程中，必须先执行父类的初始化动作。子类的构造方法中默认有一 个 super() ，表示调用父类的构造方法，父类成员变量初始化后，才可以给子类用。 当父类没有无参构造方法时，必须使用this或super调用其他的构造方法 this和super的区别 this : 代表本类对象的引用 super : 代表父类的存储空间抽象类 概念 把一类事物的共性抽取出来的那个父类, 就定义成抽象类 特点 抽象类和抽象方法都要用abstract进行修饰 抽象类不能被实例化（不能创建对象） 抽象类中不一定有抽象方法，但是有抽象方法的类一定是抽象类 抽象类中数据的特点 成员变量：可以是常量，也可以是变量 成员方法：可以是抽象方法，也可以是非抽象方法 构造方法：有 格式 abstract class 类名字 &#123; 抽象方法 普通方法 &#125; 使用 继承抽象类的子类必须重写父类所有的抽象方法。否则，该子类也必须声明为抽象类。最 终，必须有子类实现该父类的抽象方法，否则，从最初的父类到最终的子类都不能创建对象，失 去意义。 抽象类中的问题 抽象类中是否有构造方法？能不能实例化？如果不能，为什么有构造方法 抽象类有构造方法 抽象类不能被实例化 抽象类中的构造方法供子类实例化调用 抽象关键字abstract不可以和那些关键字共存 private：被修饰的内容是子类继承不到的，所以不能重写，但是abstract修饰的方 法是要求被重写的 final：被final修饰的方法是不能被重写的 static：如果一个抽象方法通过static修饰，这个方法可以直接通过类名调用，但 是抽象方法没有方法体，这样的调用没有意义 抽象类中可不可以没有抽象方法？如果可以，这样的类有什么作用？ 抽象类可以没有抽象方法 抽象类中没有抽象方法的作用，只是为了不让别的类建立该抽象类对象 群主发红包 群主发普通红包。某群有多名成员，群主给成员发普通红包。普通红包的规则： 1. 群主的一笔金额，从群主余额中扣除，平均分成n等份，让成员领取。 2. 成员领取红包后，保存到成员余额中。 // 这是一个群主类 public class GroupMaster extends User&#123; // 根据父类生成的有参构造 public GroupMaster(String username, double leftMoney) &#123; super(username, leftMoney); &#125; /** * 此方法用来发红包 * * @param money 红包总金额 * @param count 红包总个数 * @return 一个大红包 */ public ArrayList&lt;Double&gt; sendRedBag(int money, int count) &#123; // 判断自己的余额是否可以发这个红包 if (getLeftMoney() &lt; money) &#123; // 如果钱不够 // 不发红包了 return null; &#125; // 创建一个代表大红包的集合 ArrayList&lt;Double&gt; list = new ArrayList&lt;&gt;(); // 将元变成分, 减小误差 money = money * 100; // 获取每一个红包的金额 int perMoney = money / count; // 不能平均分配, 获取最后剩下的一点钱 int left = money % count; // 先不发最后一个 for (int i = 0; i &lt; count - 1; i++) &#123; list.add(perMoney / 100.0); &#125; // 只放最后一个小红包 list.add((perMoney + left) / 100.0); // 减少自己的余额 原有的余额, 减去红包的总金额 setLeftMoney(getLeftMoney() - money / 100); // 返回大红包 return list; &#125; &#125; public abstract class User &#123; private String username; private double leftMoney; public User(String username, double money) &#123; this.username = username; this.leftMoney = money; &#125; public String getUsername() &#123; return username; &#125; public void setUsername(String username) &#123; this.username = username; &#125; public double getLeftMoney() &#123; return leftMoney; &#125; public void setLeftMoney(double leftMoney) &#123; this.leftMoney = leftMoney; &#125; &#125; public class Member extends User &#123; public Member(String username, double money) &#123; super(username, money); &#125; public void openRedBag(ArrayList&lt;Double&gt; list) &#123; // 判断是否有红包 if (list == null) &#123; System.out.println(&quot;对不起, 没红包!~&quot;); // 结束方法 return; &#125; // 抢红包 // 获取集合中的值 -&gt; 值是通过索引获取 -&gt; 随机获取索引 // 创建随机数对象 Random r = new Random(); // 这个随机数的范围, 和集合的索引范围 int randomIndex = r.nextInt(list.size()); // 获取红包金额 double getMoney = list.get(randomIndex); // 红包抢一个, 没一个, 将小红包从大红包中删除 list.remove(randomIndex); // 简单修改自己的金额 setLeftMoney(getMoney); System.out.println(getUsername() + &quot;抢了&quot; + getMoney +&quot;元&quot;); &#125; &#125; public class Demo &#123; public static void main(String[] args) &#123; GroupMaster gm = new GroupMaster(&quot;杨xx&quot;, 100); Member m1 = new Member(&quot;方xx&quot;, 0); Member m2 = new Member(&quot;张x&quot;, 0); Member m3 = new Member(&quot;李x&quot;, 0); ArrayList&lt;Double&gt; list = gm.sendRedBag(200, 3); m1.openRedBag(list); m2.openRedBag(list); m3.openRedBag(list); &#125; &#125; 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859接口 概念 当一个类中的方法都是抽象的时候，java提供了另一种表示方式，叫接口 用interface关键字表示，类和接口关系用implements表示 格式 public interface 接口名称 &#123; // 抽象方法 // 默认方法 // 静态方法 // 私有方法 &#125; 抽象方法: 让子类重写 默认方法: 如果每一个子类需要具备相同的功能, 就可以再接口中定义具备这种功能的默认 方法 静态方法: 只能使用接口名. 去调用 私有方法: 只能在本类中使用, 私有的普通方法是为默认方法服务, 私有静态方法, 为普 通静态方法服务 成员特点 成员变量：是常量，默认修饰public static final 成员方法：都是抽象的，默认修饰public abstract 关系 类和类的关系 都是抽象的，默认修饰public abstract 类和接口的关系 实现关系，类可以多实现接口，使用关键字implement 类在继承一个类的同时，可以实现多个接口 接口和接口的关系 是继承关系，接口可以多继承 特点 是对外暴露的规则 是功能的扩展 接口的出现降低耦合性 接口可以多实现，如usb接口，榨汁机 和抽象类的区别 A 抽象类只能被单继承 接口可以多实现，接口的出现避免了多继承的局限性 B 抽象类中的数据特点 成员变量：可以是常量，也可以是变量 成员方法：可以是抽象方法，也可以是非抽象方法 构造方法：有 接口中的数据特点 成员变量：是常量，默认修饰public static final 成员方法：都是抽象方法，都有默认修饰public abstract 构造方法 ： 无 C 抽象类中定义的是继承体系中的共性功能 接口中定义的是继承体系中的扩展功能 注意事项 接口不能创建对象，没有构造方法 如果多个接口中有同名的抽象方法，重写一次就好了 如果多个接口中有同名的默认方法，必须重写这个默认方法 如果父类中的普通方法和接口中的默认方法同名，就近原则 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283关键字 super 1.可以用在类方法和对象方法中。 2.super必须在子类构造方法的第一行 3..在对象方法中可以使用super 关键字，调用当前对象从父类继承过来的对象方法。 4.super 特指这个方法是从父类继承过来的/super是指当前类或者对象的这个方法是从父 类继承过来的 this 1.代表本类对象的一个引用，谁调用this所在的方法，this就代表谁 2.使用场景 用于区分同名成员变量和局部变量 在定义函数时，该函数内部要用到该函数的对象时，因为此时对象还没有建立，this 可以代表此对象 构造函数时调用，this(参数)必须放在第一行 final 最终，可以用来修饰类，方法，变量 final修饰的类不能被继承 父类的private成员方法是不能被子类方法覆盖的，因为private类型的方法默认是final 类型 final修饰的方法不能被重写 final修饰的变量是一个常量只能被赋值一次 内部类只能访问被final修饰的局部变量 final不能用于修饰构造方法 内部类 将一个类A定义在另一个类B里面，里面的那个类A就称为内部类，B则称为外部类。 特点 内部类可以直接访问外部类的成员，包括私有成员。 外部类要访问内部类的成员，必须要建立内部类的对象 创建内部类对象格式 外部类名.内部类名 对象名 = new 外部类型().new 内部类型()； static 静态的，用来修饰成员变量和成员函数 静态的特点 随着类的加载而加载 优先于对象存在 所有对象共享 可以直接被调用 静态的注意事项 静态方法只能访问静态成员 静态方法中不能使用this，super关键字 主方法是静态的 public static void main(String[] args) public : 公共 最大的权限修饰符 static ： 由于JVM调用main方法的时候，没有创建对象，只能通过类名调用 void ： 由于main方法是被JVM调用，不需要返回值 String[] ： 字符串数组 args ： 数组名 静态变量和成员变量的区别 调用方式 静态变量也被称为类变量，可以直接通过类名调用，也可以通过对象名调用，这个变 量属于类 成员变量也称为实例变量，只能通过对象名调用 存储位置 静态变量存储在方法区的静态区 成员量存储在堆内存 局部变量存储在栈内存 生命周期 静态变量随着类的加载而醋在吗随着类的消失而消失，生命周期长 成员变量随着对象的创建而存在，随着对象的消失而消失 与对象的相关性 静态变量是所有对象共享的数据 成员变量是每个对象所特有的数据 静态的优势与弊端 优势 对对象的共享数据进行单独空间的存储，节省内存，不需要每个对象都存储一份 可以直接被类名调用 弊端 生命周期过长，随着类的消失而消失 访问出现权限，静态只能访问静态 什么时候使用静态 当所有对象共享某个数据的时候，就把这个成员变量定义为静态修饰变量 当某个方法没有访问该类中的非静态成员，就把这个方法定义为静态修饰 静态代码块 它只执行一次，比main先执行 执行顺序：静态代码块——构造代码块——构造方法 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170多态 概念 多态指的是编译器（申明变量时）和运行期（创建对象后）表现为不同的形态（数据类 型） 多态的前提 1、继承的存在(继承是多态的基础,没有继承就没有多态) 2、子类重写父类的方法(多态下调用子类重写的方法) 3、父类引用变量指向子类对象(子类到父类的类型转换) 对象调用成员的特点 Fu fu = new Zi(); 成员变量 编译看左边，运行看右边 成员方法 编译看左边，运行看右边 静态方法 编译看左边，运行看左边 如果参数列表是 基本数据类型, 那么传入的就是该类型的 值 如果参数列表是 类 , 那么传入的就是该类的 对象 如果参数列表是 抽象类或者是接口, 那么传入的是他们的 子类对象 参数列表是一个类/接口, 我们可以传入 它们的 子类对象 榨汁机案例 public abstract class Fruit &#123; // 榨汁 public abstract void juice(); &#125; public class Apple extends Fruit &#123; @Override public void juice() &#123; System.out.println(&quot;榨出了一杯苹果汁!~&quot;); &#125; &#125; public class Banana extends Fruit&#123; @Override public void juice() &#123; System.out.println(&quot;榨出了一杯香蕉汁!~&quot;); &#125; &#125; public class WaterMelon extends Fruit &#123; @Override public void juice() &#123; System.out.println(&quot;榨出了一杯西瓜汁!~&quot;); &#125; &#125; public class Demo &#123; public static void main(String[] args) &#123; Apple a = new Apple(); juicer(a); Banana b = new Banana(); juicer(b); WaterMelon wm = new WaterMelon(); juicer(wm); &#125; public static void juicer(Fruit f) &#123; // Fruit f = new Apple(); f.juice(); &#125; &#125; 好处和弊端 好处 多态的存在提高了程序的扩展性和后期可维护性 弊端 多态不能直接使用子类特有的属性和行为 解决弊端的方法 向下转型(强制类型转换) 1.instanceof(判断) 给引用变量做类型的校验 变量名 instanceof 数据类型 如果变量属于该数据类型，返回true。 如果变量不属于该数据类型，返回false。 2.子类类型 变量名 = (子类类型) 父类变量名; 笔记本案例 进行描述笔记本类，实现笔记本使用USB鼠标、USB键盘 USB 接口，包含开启功能、关闭功能 笔记本类，包含运行功能、关机功能、使用 USB设备功能 鼠标类，要实现 USB接口，并具备点击的方法 键盘类，要实现 USB接口，具备敲击的方法 // USB接口 public interface USB &#123; // 插入功能, 开启 public abstract void open(); // 拔出功能, 关闭 public abstract void close(); &#125; public class Mouse implements USB &#123; @Override public void open() &#123; System.out.println(&quot;插上了鼠标&quot;); &#125; public void click() &#123; System.out.println(&quot;点击鼠标, 玩游戏&quot;); &#125; @Override public void close() &#123; System.out.println(&quot;拔出了鼠标&quot;); &#125; &#125; public class Keyboard implements USB&#123; @Override public void open() &#123; System.out.println(&quot;插上了键盘&quot;); &#125; public void type() &#123; System.out.println(&quot;敲击键盘, 写代码&quot;); &#125; @Override public void close() &#123; System.out.println(&quot;拔出了键盘&quot;); &#125; &#125; /* 笔记本类 */ public class Laptop &#123; public void start() &#123; System.out.println(&quot;笔记本电脑开机&quot;); &#125; // 使用USB设备 public void useUSBDevice(USB usb) &#123; // USB usb = new Mouse(); usb.open(); // 由于多态进行了向上转型, 所以不能直接使用子类特有的属性和行为 // 想使用, 需要先向下转型 // 如果是鼠标类, 就转换成鼠标 if (usb instanceof Mouse) &#123; ((Mouse) usb).click(); &#125;else if (usb instanceof Keyboard) &#123; ((Keyboard) usb).type(); &#125; usb.close(); &#125; public void stop() &#123; System.out.println(&quot;笔记本电脑关机&quot;); &#125; &#125; public class Demo &#123; public static void main(String[] args) &#123; Laptop l = new Laptop(); // 创建鼠标对象 Mouse m = new Mouse(); // 创建键盘对象 Keyboard k = new Keyboard(); l.start(); // 使用usb设备 l.useUSBDevice(m); l.useUSBDevice(k); l.stop(); &#125; &#125;]]></content>
  </entry>
  <entry>
    <title><![CDATA[JAVA基础]]></title>
    <url>%2F2019%2F05%2F28%2Fjava%E5%9F%BA%E7%A1%80%2F</url>
    <content type="text"><![CDATA[java入门 1、java基础a、基本概念123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263标识符 Java所有的组成部分都需要名字。类名、变量名以及方法名都被称为标识符。 标识符命名规则: 1. 标识符可以包含 英文字母 26个(区分大小写) 、 0 -9数字 、 $ （美元符号） 和 _（下划线） 。 2. 标识符不能以数字开头。 3. 标识符不能是关键字。 标识符命名规范: 1. 类名规范：首字母大写，后面每个单词首字母大写（大驼峰式）。 2. 方法名规范： 首字母小写，后面每个单词首字母大写（小驼峰式）。 3. 变量名规范：首字母小写，后面每个单词首字母大写（小驼峰式）。 合法标识符举例：age、$salary、_value、__1_value 非法标识符举例：123abc、-salary 关键字 关键字（或者保留字）是对编译器有特殊意义的固定单词，不能在程序中做其他目的使用。关键字具有专门的意义和用途，和自定义的标识符不同，不能当作一般的标识符来使用。 51 个关键字: 1. 数据类型：boolean、int、long、short、byte、float、double、char、class、 interface。 2. 流程控制：if、else、do、while、for、switch、case、default、break、 continue、return、try、catch、finally。 3. 修饰符：public、protected、private、final、void、static、strict、 abstract、transient、synchronized、volatile、native。 4. 动作：package、import、throw、throws、extends、implements、this、 supper、instanceof、new。 5. 保留字：true、false、null、goto、const。注释 注释是对程序语言的说明，有助于开发者和用户之间的交流，方便理解程序。注释不是编程语句，因此被编译器忽略。 常用注释 1. 单行注释以 // 开头 换行结束 2. 多行注释以 /* 开头 以*/结束 3. 文档注释以/*开头 以/结束枚举 概念 枚举限制变量只能是预先设定好的值。 注意点 枚举可以单独声明或者声明在类里面。 方法、变量、构造函数也可以在枚举中定义。数组 数组是储存在堆上的对象，可以保存多个同类型变量。对象 对象是类的一个实例，有状态和行为。例如，一条狗是一个对象，它的状态有：颜色、名字、品种；行为有：摇尾巴、叫、吃等。 类 类是一个模板，它描述一类对象的行为和状态。 方法 方法就是行为，一个类可以有很多方法。逻辑运算、数据修改以及所有动作都是在方法中完成的。 定义方法的格式详解 修饰符 返回值类型 方法名(参数列表)&#123; //代码省略... return 结果; &#125; 定义方法的两个明确 明确返回值类型 明确参数列表 定义方法的注意事项 定义位置，类中方法外面。 返回值类型，必须要和 return 语句返回的类型相同，否则编译失败 。 123456 方法重载 ：指在同一个类中，允许存在一个以上的同名方法，只要它们的参数列表不同即 可，与修饰符和返回值类型无关。 参数列表：个数不同，数据类型不同，顺序不同。 重载方法调用： JVM通过方法的参数列表，调用不同的方法 实例变量 每个对象都有独特的实例变量，对象的状态由这些实例变量的值决定。 b、基本语法1234567891011121314大小写敏感 Java是大小写敏感的，这就意味着标识符Hello与hello是不同的。 类名 对于所有的类来说，类名的首字母应该大写。如果类名由若干单词组成，那么每个单词的首字母应该大写，例如 MyFirstJavaClass 。 方法名 所有的方法名都应该以小写字母开头。如果方法名含有若干单词，则后面的每个单词首字母大写。 源文件名 源文件名必须和类名相同。当保存文件的时候，你应该使用类名作为文件名保存（切记Java是大小写敏感的），文件名的后缀为.java。。 主方法入口 所有的Java 程序由public static void main(String []args)方法开始执行。 2、java数据类型a、数据类型分类123基本数据类型 ：包括 整数 、 浮点数 、 字符 、 布尔 。引用数据类型 ：包括 类 、 数组 、 接口 。 b、基本数据类型123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263概述 Java语言提供了八种基本类型。六种数字类型（四个整数型，两个浮点型），一种字符类型，还有一种布尔型。 类型 byte byte数据类型是8位、有符号的，以二进制补码表示的整数 最小值是-128（-2^7） 最大值是127（2^7-1） 默认值是0 byte类型用在大型数组中节约空间，主要代替整数，因为byte变量占用的空间只有int类型的四分之一 例子：byte a = 100，byte b = -50 short short数据类型是16位、有符号的以二进制补码表示的整数 最小值是-32768（-2^15）； 最大值是32767（2^15 - 1）； Short数据类型也可以像byte那样节省空间。一个short变量是int型变量所占空间的二分之一； 默认值是0； 例子：short s = 1000，short r = -20000。 int int数据类型是32位、有符号的以二进制补码表示的整数； 最小值是-2,147,483,648（-2^31）； 最大值是2,147,483,647（2^31 - 1）； 一般地整型变量默认为int类型； 默认值是0； 例子：int a = 100000, int b = -200000。 long long数据类型是64位、有符号的以二进制补码表示的整数； 最小值是-9,223,372,036,854,775,808（-2^63）； 最大值是9,223,372,036,854,775,807（2^63 -1）； 这种类型主要使用在需要比较大整数的系统上； 默认值是0L； 例子： long a = 100000L，Long b = -200000L。 float float数据类型是单精度、32位、符合IEEE 754标准的浮点数； float在储存大型浮点数组的时候可节省内存空间； 默认值是0.0f； 浮点数不能用来表示精确的值，如货币； 例子：float f1 = 234.5f。 double double数据类型是双精度、64位、符合IEEE 754标准的浮点数； 浮点数的默认类型为double类型； double类型同样不能表示精确的值，如货币； 默认值是0.0d； 例子：double d1 = 123.4。 boolean boolean数据类型表示一位的信息； 只有两个取值：true和false； 这种类型只作为一种标志来记录true/false情况； 默认值是false； 例子：boolean one = true。 char char类型是一个单一的16位Unicode字符； 最小值是’\u0000’（即为0）； 最大值是’\uffff’（即为65,535）； char数据类型可以储存任何字符； 例子：char letter = ‘A’。 c、引用数据类型12345在Java中，引用类型的变量非常类似于C/C++的指针。引用类型指向一个对象，指向对象的变量是引用变量。这些变量在声明时被指定为一个特定的类型，比如Employee、Pubby等。变量一旦声明后，类型就不能被改变了。 对象、数组都是引用数据类型。 所有引用类型的默认值都是null。 一个引用变量可以用来引用与任何与之兼容的类型。 例子：Site site = new Site(&quot;Runoob&quot;)。 d、数据类型转换1）自动类型转换123456789101112低 ------------------------------------&gt; 高byte,short,char—&gt; int —&gt; long—&gt; float —&gt; double 整型、实型（常量）、字符型数据可以混合运算。运算中，不同类型的数据先转化为同一类型，然后进行运算。规则 1. 不能对boolean类型进行类型转换。 2. 不能把对象类型转换成不相关类的对象。 3. 在把容量大的类型转换为容量小的类型时必须使用强制类型转换。 4. 转换过程中可能导致溢出或损失精度 int i =128; byte b = (byte)i; 因为byte类型时8位，最大值为127，所以当强制转换为int类型值128时候就会导致溢出。 5. 浮点数到整数的转换是通过舍弃小数得到，而不是四舍五入 6. 必须满足转换前的数据类型的位数要低于转换后的数据类型 2）强制类型转换121. 条件是转换的数据类型必须是兼容的。2. 格式：(type)value type是要强制类型转换后的数据类型 3）隐含强制类型转换121. 整数的默认类型是 int。2. 浮点型不存在这种情况，因为在定义 float 类型时必须在数字后面跟上 F 或者 f。 3、Java常量12345678910111213141516171819202122232425常量在程序运行时，不会被修改的量在 Java 中使用 final 关键字来修饰常量，声明方式和变量类似例子： final double PI = 3.1415927;为了便于识别，通常使用大写字母表示常量当使用常量的时候，前缀0表示8进制，而前缀0x代表16进制，如： int hexa = 0x64;字符串常量和字符常量都可以包含任何Unicode字符，如： char a = &apos;\u0001&apos;; 特殊的转义字符序列 符号 字符含义 \n 换行 (0x0a) \r 回车 (0x0d) \f 换页符(0x0c) \b 退格 (0x08) \s 空格 (0x20) \t 制表符 \&quot; 双引号 \\ 反斜杠 \&apos; 单引号 \ddd 八进制字符 (ddd) \uxxxx 16进制Unicode字符 (xxxx) 4、java变量1变量就是申请内存来存储值，当创建变量的时候，需要在内存中申请空间 1内存管理系统根据变量的类型为变量分配存储空间，分配的空间只能用来储存该类型数据。 变量分类1)局部变量1234561、局部变量声明在方法、构造方法或者语句块中；2、局部变量在方法、构造方法、或者语句块被执行的时候创建，当它们执行完成后，变量将会被销毁；3、访问修饰符不能用于局部变量；4、局部变量只在声明它的方法、构造方法或者语句块中可见；5、局部变量是在栈上分配的。6、局部变量没有默认值，所以局部变量被声明后，必须经过初始化，才可以使用。 2)实例变量1234567891、实例变量声明在一个类中，但在方法、构造方法和语句块之外；2、当一个对象被实例化之后，每个实例变量的值就跟着确定；3、实例变量在对象创建的时候创建，在对象被销毁的时候销毁；4、实例变量的值应该至少被一个方法、构造方法或者语句块引用，使得外部能够通过这些方式获取实例变量信息；5、实例变量可以声明在使用前或者使用后；6、访问修饰符可以修饰实例变量；7、实例变量对于类中的方法、构造方法或者语句块是可见的。一般情况下应该把实例变量设为私有。8、通过使用访问修饰符可以使实例变量对子类可见；9、实例变量具有默认值。数值型变量的默认值是0，布尔型变量的默认值是false，引用类型变量的默认值是null。变量的值可以在声明时指定，也可以在构造方法中指定；10、实例变量可以直接通过变量名访问。但在静态方法以及其他类中，就应该使用完全限定名：ObejectReference.VariableName。 3)类变量（静态变量）1234567891、类变量也称为静态变量，在类中以static关键字声明，但必须在方法构造方法和语句块之外。2、无论一个类创建了多少个对象，类只拥有类变量的一份拷贝。3、静态变量除了被声明为常量外很少使用。常量是指声明为public/private，final和static类型的变量。常量初始化后不可改变。4、静态变量储存在静态存储区。经常被声明为常量，很少单独使用static声明变量。5、静态变量在程序开始时创建，在程序结束时销毁。6、与实例变量具有相似的可见性。但为了对类的使用者可见，大多数静态变量声明为public类型。7、默认值和实例变量相似。数值型变量默认值是0，布尔型默认值是false，引用类型默认值是null。变量的值可以在声明的时候指定，也可以在构造方法中指定。此外，静态变量还可以在静态语句块中初始化。8、静态变量可以通过：ClassName.VariableName的方式访问。9、类变量被声明为public static final类型时，类变量名称一般建议使用大写字母。如果静态变量不是public和final类型，其命名方式与实例变量以及局部变量的命名方式一致。 4)_静态变量和实例变量的区别123实例变量属于某个对象的属性，必须创建了实例对象，其中的实例变量才会被分配空间，才能使用这个实例变量。静态变量不属于某个实例对象，而是属于类，所以也称为类变量，只要程序加载了类的字节码，不用创建任何实例对象，静态变量就会被分配空间，静态变量就可以被使用了 5、java运算符a、常用运算符123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108算术运算符 + 加法 - 相加运算符两侧的值 A + B 等于 30 - 减法 - 左操作数减去右操作数 A – B 等于 -10 * 乘法 - 相乘操作符两侧的值 A * B等于200 / 除法 - 左操作数除以右操作数 B / A等于2 ％ 取模 - 左操作数除右操作数的余数 B%A等于0 ++ 自增: 操作数的值增加1 B++ 或 ++B 等于 21（区别详见下文） -- 自减: 操作数的值减少1 B-- 或 --B 等于 19（区别详见下文） 自增自减运算符 自增（++）自减（--）运算符是一种特殊的算术运算符，在算术运算符中需要两个操作数来进行运算，而自增自减运算符是一个操作数 （i ++）表示运算完成之后增1，（++ i）表示增1之后再运算 关系运算符 == 检查如果两个操作数的值是否相等，如果相等则条件为真。 （A == B）为假(非真)。 != 检查如果两个操作数的值是否相等，如果值不相等则条件为真。 (A != B) 为真。 &gt; 检查左操作数的值是否大于右操作数的值，如果是那么条件为真。 （A&gt; B）非真。 &lt; 检查左操作数的值是否小于右操作数的值，如果是那么条件为真。 （A &lt;B）为真。 &gt; = 检查左操作数的值是否大于或等于右操作数的值，如果是那么条件为真。 （A&gt; = B）为假。 &lt;= 检查左操作数的值是否小于或等于右操作数的值，如果是那么条件为真。 （A &lt;= B）为真。 位运算符 Java定义了位运算符，应用于整数类型(int)，长整型(long)，短整型(short)，字符型(char)，和字节型(byte)等类型。位运算符作用在所有的位上，并且按位运算 ＆ 如果相对应位都是1，则结果为1，否则为0 （A＆B），得到12，即0000 1100 | 如果相对应位都是0，则结果为0，否则为1 （A | B）得到61，即 0011 1101 ^ 如果相对应位值相同，则结果为0，否则为1 （A ^ B）得到49，即 0011 0001 〜 按位补运算符翻转操作数的每一位，即0变成1，1变成0。 （〜A）得到-61，即1100 0011 &lt;&lt; 按位左移运算符。左操作数按位左移右操作数指定的位数。 A &lt;&lt; 2得到240，即 1111 0000 &gt;&gt; 按位右移运算符。左操作数按位右移右操作数指定的位数。 A &gt;&gt; 2得到15即 1111 &gt;&gt;&gt; 按位右移补零操作符。左操作数的值按右操作数指定的位数右移，移动得到的空位以零填充。 A&gt;&gt;&gt;2得到15即0000 1111 逻辑运算符 &amp;&amp; 称为逻辑与运算符。当且仅当两个操作数都为真，条件才为真。 （ A &amp;&amp; B）为假。 | | 称为逻辑或操作符。如果任何两个操作数任何一个为真，条件为真。 （A | | B）为真。 ！ 称为逻辑非运算符。用来反转操作数的逻辑状态。如果条件为true，则逻辑非运算符将得到false。 ！（A &amp;&amp; B）为真。 当使用与逻辑运算符时，在两个操作数都为true时，结果才为true，但是当得到第一个操作为false时，其结果就必定是false，这时候就不会再判断第二个操作了。 赋值运算符 = 简单的赋值运算符，将右操作数的值赋给左侧操作数 C = A + B将把A + B得到的值赋给C + = 加和赋值操作符，它把左操作数和右操作数相加赋值给左操作数 C + = A等价于C = C + A - = 减和赋值操作符，它把左操作数和右操作数相减赋值给左操作数 C - = A等价于C = C - A * = 乘和赋值操作符，它把左操作数和右操作数相乘赋值给左操作数 C * = A等价于C = C * A / = 除和赋值操作符，它把左操作数和右操作数相除赋值给左操作数 C / = A等价于C = C / A ％ = 取模和赋值操作符，它把左操作数和右操作数取模后赋值给左操作数 C％= A等价于C = C％A &lt;&lt; = 左移位赋值运算符 C &lt;&lt; = 2等价于C = C &lt;&lt; 2 &gt;&gt; = 右移位赋值运算符 C &gt;&gt; = 2等价于C = C &gt;&gt; 2 ＆ = 按位与赋值运算符 C＆= 2等价于C = C＆2 ^ = 按位异或赋值操作符 C ^ = 2等价于C = C ^ 2 | = 按位或赋值操作符 C | = 2等价于C = C | 2其他运算符 条件运算符（?:） 条件运算符也被称为三元运算符。该运算符有3个操作数，并且需要判断布尔表达式的值。 该运算符的主要是决定哪个值应该赋值给变量 variable x = (expression) ? value if true : value if false instanceof 运算符 该运算符用于操作对象实例，检查该对象是否是一个特定类型（类类型或接口类型） ( Object reference variable ) instanceof (class/interface type) b、Java运算符优先级123456789101112131415后缀 () [] . (点操作符) 左到右一元 + + - ！〜 从右到左乘性 * /％ 左到右加性 + - 左到右移位 &gt;&gt; &gt;&gt;&gt; &lt;&lt; 左到右关系 &gt;&gt; = &lt;&lt; = 左到右相等 == != 左到右按位与 ＆ 左到右按位异或 ^ 左到右按位或 | 左到右逻辑与 &amp;&amp; 左到右逻辑或 | | 左到右条件 ？： 从右到左赋值 = + = - = * = / =％= &gt;&gt; = &lt;&lt; =＆= ^ = | = 从右到左逗号 ， 左到右 6、java修饰符123456789101112131415161718192021222324概念 修饰符用来定义类、方法或者变量，通常放在语句的最前端。访问控制修饰符 Java中，可以使用访问控制符来保护对类、变量、方法和构造方法的访问。Java支持4种不同的 访问权限 访问控制 ![avatar](https://s2.ax1x.com/2019/05/02/ENizy8.png) 访问控制和继承 父类中声明为 public 的方法在子类中也必须为 public。 父类中声明为 protected 的方法在子类中要么声明为 protected，要么声明为 public，不能声明为 private。 父类中声明为 private 的方法，不能够被继承。 非访问修饰符 static 修饰符，用来创建类方法和类变量。 final 修饰符，用来修饰类、方法和变量，final 修饰的类不能够被继承，修饰的方法不能被 继承类重新定义，修饰的变量为常量，是不可修改的。 abstract 修饰符，用来创建抽象类和抽象方法。 synchronized 和 volatile 修饰符，主要用于线程的编程。 7、java流程控制语句a、java分支结构123456789101112131415161718192021222324252627282930313233if 语句 if(布尔表达式) &#123; //如果布尔表达式为true将执行的语句 &#125; if 语句 一个 if 语句包含一个布尔表达式和一条或多条语句 if...else语句 if 语句后面可以跟 else 语句，当 if 语句的布尔表达式值为 false 时，else 语句块会被执行 if...else if...else 语句 if 语句至多有 1 个 else 语句，else 语句在所有的 elseif 语句之后。 if 语句可以有若干个 elseif 语句，它们必须在 else 语句之前。 一旦其中一个 else if 语句检测为 true，其他的 else if 以及 else 语句都将跳过执行。 嵌套的 if…else 语句 switch 语句 switch 语句判断一个变量与一系列值中某个值是否相等，每个值称为一个分支 switch 语句中的变量类型可以是： byte、short、int 或者 char。从 Java SE 7 开始，switch 支持字符串类型了，同时 case 标签必须为字符串常量或字面量。 switch 语句可以拥有多个 case 语句。每个 case 后面跟一个要比较的值和冒号。 case 语句中的值的数据类型必须与变量的数据类型相同，而且只能是常量或者字面常量。 当变量的值与 case 语句的值相等时，那么 case 语句之后的语句开始执行，直到 break 语句出现才会跳出 switch 语句。 当遇到 break 语句时，switch 语句终止。程序跳转到 switch 语句后面的语句执行。case 语句不必须要包含 break 语句。如果没有 break 语句出现，程序会继续执行下一条 case 语句，直到出现 break 语句。 switch 语句可以包含一个 default 分支，该分支必须是 switch 语句的最后一个分支。default 在没有 case 语句的值和变量值相等的时候执行。default 分支不需要 break 语句。 b、java循环结构12345678910111213141516171819202122232425262728293031323334353637383940414243while 循环 只要布尔表达式为 true，循环体会一直执行下去 while( 布尔表达式 ) &#123; //循环内容 &#125; do…while 循环 对于 while 语句而言，如果不满足条件，则不能进入循环。但有时候我们需要即使不满足条件，也至少执行一次 do &#123; //代码语句 &#125;while(布尔表达式) 区别 do…while 循环和 while 循环相似，不同的是，do…while 循环至少会执行一次。 for 循环 最先执行初始化步骤。可以声明一种类型，但可初始化一个或多个循环控制变量，也可以是空语句。 然后，检测布尔表达式的值。如果为 true，循环体被执行。如果为false，循环终止，开始执行循环体后面的语句。 执行一次循环后，更新循环控制变量。 再次检测布尔表达式。循环执行上面的过程。 for(初始化; 布尔表达式; 更新) &#123; //代码语句 &#125;Java 增强 for 循环 for(声明语句 : 表达式)&#123; //代码句子 &#125; 声明新的局部变量，该变量的类型必须和数组元素的类型匹配 其作用域限定在循环语句块，其值与此时数组元素的值相等。 break 关键字 break 主要用在循环语句或者 switch 语句中，用来跳出整个语句块。 break 跳出最里层的循环，并且继续执行该循环下面的语句。 continue 关键字 continue 适用于任何循环控制结构中。作用是让程序立刻跳转到下一次循环的迭代。 在 for 循环中，continue 语句使程序立即跳转到更新语句。 在 while 或者 do…while 循环中，程序立即跳转到布尔表达式的判断语句。 8、java数组123456789101112131415161718192021222324252627282930数组 数组是储存在堆上的对象，可以保存多个同类型变量。声明数组变量 dataType[] arrayRefVar; // 首选的方法 dataType arrayRefVar[]; // 效果相同，但不是首选方法 创建数组 1、arrayRefVar = new dataType[arraySize]; 2、arrayRefVar = new dataType[value0, value1, ..., valuek]; 3、dataType[] arrayRefVar = &#123;value0, value1, ..., valuek&#125;; 数组索引从 0 开始，所以索引值从 0 到 arrayRefVar.length-1 处理数组 数组的元素类型和数组的大小都是确定的，使用基本循环或者 foreach 循环处理数组元素 double[] myList = &#123;1.9, 2.9, 3.4, 3.5&#125;; // 打印所有数组元素for (double element: myList) &#123; System.out.println(element);&#125;数组作为方法参数传递，传递的参数是数组内存的地址。数组作为方法的返回值，返回的是数组的内存地址方法的参数为基本类型时,传递的是数据值方法的参数为引用类型时,传递的是地址值多维数组 多维数组的动态初始化（以二维数组为例） type[ ][ ] arrayName = new typ[arraylenght1][arraylenght2];]]></content>
  </entry>
</search>
